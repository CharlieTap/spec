;;
;; Text Format of Modules
;;

;; Tags

grammar Ttag_(I) : (tag, name?) =
  | "(" "tag" id?:Tid? jt:Ttagtype_(I) ")" => (TAG jt, id?)


;; Globals

grammar Tglobal_(I) : (global, name?) =
  | "(" "global" id?:Tid? gt:Tglobaltype_(I) e:Texpr_(I) ")" => (GLOBAL gt e, id?)


;; Memories

grammar Tmem_(I) : (mem, name?) =
  | "(" "memory" id?:Tid? mt:Tmemtype_(I) ")" => (MEMORY mt, id?)


;; Tables

grammar Ttable_(I) : (table, name?) =
  | "(" "table" id?:Tid? tt:Ttabletype_(I) e:Texpr_(I) ")" => (TABLE tt e, id?)
  | ...

grammar Ttable_(I)/abbrev : (table, name?) = ...
  | "(" "table" Tid? tt:Ttabletype_(I) ")" ==
    "(" "table" Tid? tt:Ttabletype_(I) "(" "ref.null" ht:Theaptype_(I) ")" ")"
    -- if tt = at lim (REF NULL? ht)


;; Functions

grammar Tfunc_(I) : (func, name?) =
  | "(" "func" id?:Tid? (x,I'):Ttypeuse_(I) ((loc*,id'?*):Tlocal_(I))* e:Texpr_(I'') ")" => (FUNC x $concat_(local, loc**) e, id?)
    -- if I'' = I ++ I' ++ {LOCALS $concat_(name?, (id'?)**)}
;; TODO(4, rossberg): Idcontext_ok
;;    -- Idcontext_ok: I'' OK

grammar Tlocal_(I) : (local*, name?*) =
  | "(" "local" id?:Tid? t:Tvaltype_(I) ")" => (LOCAL t, id?)
  | ...

grammar Tlocal_(I)/abbrev : (local*, name?*) = ...
  | "(" "local" t:Tvaltype_(I)* ")" == ("(" "local" t:Tvaltype_(I) ")")*


;; Data segments

grammar Tdata_(I) : (data, name?) =
  | "(" "data" id?:Tid? b*:Tdatastring ")" => (DATA b* PASSIVE, id?)
  | "(" "data" id?:Tid? b*:Tdatastring x:Tmemuse_(I) e:Toffset_(I) ")" => (DATA b* (ACTIVE x e), id?)

grammar Tdatastring : byte* =
  | b**:Tstring* => $concat_(byte, b**)

grammar Tmemuse_(I) : memidx =
  | "(" "memory" x:Tmemidx_(I) ")" => x
  | ...

grammar Tmemuse_(I)/abbrev : memidx = ...
  | eps => 0

grammar Toffset_(I) : expr =
  | "(" "offset" e:Texpr_(I) ")" => e
  | ...

grammar Toffset_(I)/abbrev : expr = ...
  | Tfoldedinstr_(I) == "(" "offset" Tfoldedinstr_(I) ")"


;; Element segments

grammar Telem_(I) : (elem, name?) =
  | "(" "elem" id?:Tid? (rt,e*):Telemlist_(I) ")" => (ELEM rt e* PASSIVE, id?)
  | "(" "elem" id?:Tid? (rt,e*):Telemlist_(I) x:Ttableuse_(I) e':Toffset_(I) ")" => (ELEM rt e* (ACTIVE x e'), id?)
  | "(" "elem" id?:Tid? "declare" (rt,e*):Telemlist_(I) ")" => (ELEM rt e* DECLARE, id?)

grammar Telemlist_(I) : (reftype, expr*) =
  | rt:Treftype_(I) e*:Tlist(Texpr_(I)) => (rt, e*)
  | ...

grammar Telemlist_(I)/abbrev : (reftype, expr*) = ...
  | "func" x*:Tfuncidx_(I)* ==
    "(" "ref" "func" ")" ("(" "ref.func" Tfuncidx_(I) ")")*

grammar Telemexpr_(I) : expr =
  | "(" "item" e:Texpr_(I) ")" => e
  | ...

grammar Telemexpr_(I)/abbrev : expr = ...
  | Tfoldedinstr_(I) == "(" "item" Tfoldedinstr_(I) ")"

grammar Ttableuse_(I) : tableidx =
  | "(" "table" x:Ttableidx_(I) ")" => x
  | ...

grammar Ttableuse_(I)/abbrev : tableidx = ...
  | eps => 0


;; Start functions

grammar Tstart_(I) : start =
  | "(" "start" x:Tfuncidx_(I) ")" => START x


;; Imports

grammar Timport_(I) : (import, I) =
  | "(" "import" nm_1:Tname nm_2:Tname (xt,I'):Texterntype_(I) ")" => (IMPORT nm_1 nm_2 xt, I')
  | ...

grammar Timport_(I)/abbrev : (import, I) = ...
  | "(" "tag" Tid? "(" "import" Tname^2 ")" Ttagtype_(I) ")" ==
    "(" "import" Tname^2 "(" "tag" Tid? Ttagtype_(I) ")" ")"
  | "(" "global" Tid? "(" "import" Tname^2 ")" Tglobaltype_(I) ")" ==
    "(" "import" Tname^2 "(" "global" Tid? Tglobaltype_(I) ")" ")"
  | "(" "memory" Tid? "(" "import" Tname^2 ")" Tmemtype_(I) ")" ==
    "(" "import" Tname^2 "(" "memory" Tid? Tmemtype_(I) ")" ")"
  | "(" "table" Tid? "(" "import" Tname^2 ")" Ttabletype_(I) ")" ==
    "(" "import" Tname^2 "(" "table" Tid? Ttabletype_(I) ")" ")"
  | "(" "func" Tid? "(" "import" Tname^2 ")" Ttypeuse_(I) ")" ==
    "(" "import" Tname^2 "(" "func" Tid? Ttypeuse_(I) ")" ")"


;; Exports

grammar Texport_(I) : export =
  | "(" "export" nm:Tname xx:Texternidx_(I) ")" => EXPORT nm xx

grammar Texportdots = "(" "export" Tname ")"
grammar Timportdots = "(" "import" Tname Tname ")"

grammar Texporttagdots_(I) hint(show `...) =
  | Texportdots* Ttagtype_(I)
  | Texportdots* Timportdots Ttagtype_(I)
grammar Texportglobaldots_(I) hint(show `...) =
  | Texportdots* Tglobaltype_(I) Texpr_(I)
  | Texportdots* Timportdots Tglobaltype_(I)
grammar Texportmemorydots_(I) hint(show `...) =
  | Texportdots* Tmemtype_(I)
  | Texportdots* Taddrtype? "(" "data" Tdatastring ")"
  | Texportdots* Timportdots Tmemtype_(I)
grammar Texporttabledots_(I) hint(show `...) =
  | Texportdots* Ttabletype_(I) Texpr_(I)?
  | Texportdots* Taddrtype? Treftype_(I) "(" "elem" Telemlist_(I) ")"
  | Texportdots* Timportdots Ttabletype_(I)
grammar Texportfuncdots_(I) hint(show `...) =
  | Texportdots* Ttypeuse_(I) Tlocal_(I)* Texpr_(I)
  | Texportdots* Timportdots Ttypeuse_(I)


;; TODO(5, rossberg): make properly typed

grammar Texporttag_(I)/abbrev : () =
  | "(" "tag" id?:Tid? "(" "export" Tname ")" Texporttagdots_(I) ")" ==
    "(" "tag" id':Tid Texporttagdots_(I) ")"
    "(" "export" Tname "(" "tag" Tid ")" ")"
    ----
    -- if id? = id' \/ id? = eps /\ ~(id' <- I.TAGS)

grammar Texportglobal_(I)/abbrev : () =
  | "(" "global" id?:Tid? "(" "export" Tname ")" Texportglobaldots_(I) ")" ==
    "(" "global" id':Tid Texportglobaldots_(I) ")"
    "(" "export" Tname "(" "global" Tid ")" ")"
    ----
    -- if id? = id' \/ id? = eps /\ ~(id' <- I.GLOBALS)

grammar Texportmemory_(I)/abbrev : () =
  | "(" "memory" id?:Tid? "(" "export" Tname ")" Texportmemorydots_(I) ")" ==
    "(" "memory" id':Tid Texportmemorydots_(I) ")"
    "(" "export" Tname "(" "memory" Tid ")" ")"
    ----
    -- if id? = id' \/ id? = eps /\ ~(id' <- I.MEMS)

grammar Texporttable_(I)/abbrev : () =
  | "(" "table" id?:Tid? "(" "export" Tname ")" Texporttabledots_(I) ")" ==
    "(" "table" id':Tid Texporttabledots_(I) ")"
    "(" "export" Tname "(" "table" Tid ")" ")"
    ----
    -- if id? = id' \/ id? = eps /\ ~(id' <- I.TABLES)

grammar Texportfunc_(I)/abbrev : () =
  | "(" "func" id?:Tid? "(" "export" Tname ")" Texportfuncdots_(I) ")" ==
    "(" "func" id':Tid Texportfuncdots_(I) ")"
    "(" "export" Tname "(" "func" Tid ")" ")"
    ----
    -- if id? = id' \/ id? = eps /\ ~(id' <- I.FUNCS)


grammar Tdatamemory_(I)/abbrev : () =
  | "(" "memory" id?:Tid? at?:Taddrtype? "(" "data" b*:Tdatastring ")" ")" ==
    "(" "memory" id':Tid at?:Taddrtype? n:Tu64 n:Tu64 ")"
    "(" "data" "(" "memory" id':Tid ")" "(" at':Taddrtype ".const" "0" ")" Tdatastring ")"
    ----
    -- if id? = id' \/ id? = eps /\ ~(id' <- I.MEMS)
    -- if at? = at' \/ at? = eps /\ at' = I32
;; TODO(4, rossberg): define $ceil
;;    -- if n = $ceil($(|b*| / 64*$Ki))

grammar Telemtable_(I)/abbrev : () =
  | "(" "table" id?:Tid? at?:Taddrtype? Treftype_(I) "(" "elem" (rt,e*):Telemlist_(I) ")" ")" ==
    "(" "table" id':Tid at?:Taddrtype? n:Tu64 n:Tu64 Treftype_(I) ")"
    "(" "elem" "(" "table" id':Tid ")" "(" at':Taddrtype ".const" "0" ")" Telemlist_(I) ")"
    ----
    -- if id? = id' \/ id? = eps /\ ~(id' <- I.TABLES)
    -- if at? = at' \/ at? = eps /\ at' = I32
    -- if n = |e*|


;; Modules

;; TODO(4, rossberg): modules
(;
grammar Tmodule : module =
  | "(" "module" Tid? fld*:Tmodulefield_(I)* ")" =>
    MODULE type* import* tag* global* mem* table* func* data* elem* start* export*
    -- if I = (++) 

.. math::
   \begin{array}{lll}
   \production{module} & \Tmodule &
   \begin{array}[t]{@{}cllll}
   ::=&
     \text{(}~\text{module}~~\Tid^?~~(m{:}\Tmodulefield_I)^\ast~\text{)}
       \quad\Rightarrow\quad \bigcompose m^\ast \\
       &\qquad (\iff I = \bigcompose \F{idc}(\Tmodulefield)^\ast \idcwellformed) \\
   \end{array} \\[1ex]
   \production{module field} & \Tmodulefield_I &
   \begin{array}[t]{@{}clll}
   ::=&
     \X{ty}^\ast{:}\Trectype_I &\Rightarrow& \{\MTYPES~\X{ty}^\ast\} \\ |&
     \X{tg}{:}\Ttag_I &\Rightarrow& \{\MTAGS~\X{tg}\} \\ |&
     \X{gl}{:}\Tglobal_I &\Rightarrow& \{\MGLOBALS~\X{gl}\} \\ |&
     \X{me}{:}\Tmem_I &\Rightarrow& \{\MMEMS~\X{me}\} \\ |&
     \X{ta}{:}\Ttable_I &\Rightarrow& \{\MTABLES~\X{ta}\} \\ |&
     \X{fn}{:}\Tfunc_I &\Rightarrow& \{\MFUNCS~\X{fn}\} \\ |&
     \X{da}{:}\Tdata_I &\Rightarrow& \{\MDATAS~\X{da}\} \\ |&
     \X{el}{:}\Telem_I &\Rightarrow& \{\MELEMS~\X{el}\} \\ |&
     \X{st}{:}\Tstart_I &\Rightarrow& \{\MSTART~\X{st}\} \\ |&
     \X{im}{:}\Timport_I &\Rightarrow& \{\MIMPORTS~\X{im}\} \\ |&
     \X{ex}{:}\Texport_I &\Rightarrow& \{\MEXPORTS~\X{ex}\} \\
   \end{array}
   \end{array}

The following restrictions are imposed on the composition of :ref:`modules <syntax-module>`: :math:`m_1 \compose m_2` is defined if and only if

* :math:`m_1.\MSTART = \epsilon \vee m_2.\MSTART = \epsilon`

* :math:`m_1.\MFUNCS = m_1.\MTABLES = m_1.\MMEMS = m_1.\MGLOBALS = m_1.\MTAGS = \epsilon \vee m_2.\MIMPORTS = \epsilon`

.. note::
   The first condition ensures that there is at most one start function.
   The second condition enforces that all :ref:`imports <text-import>` must occur before any regular definition of a
   :ref:`tag <text-tag>`,
   :ref:`global <text-global>`,
   :ref:`memory <text-mem>`,
   :ref:`table <text-table>`, or
   :ref:`function <text-func>`,
   thereby maintaining the ordering of the respective :ref:`index spaces <syntax-index>`.

   The :ref:`well-formedness <text-context-wf>` condition on :math:`I` in the grammar for |Tmodule| ensures that no namespace contains duplicate identifiers.

The definition of the initial :ref:`identifier context <text-context>` :math:`I` uses the following auxiliary definition which maps each relevant definition to a singular context with one (possibly empty) identifier:

.. math::
   \begin{array}{@{}lcl@{\qquad\qquad}l}
   \F{idc}(\text{(}~\text{rec}~~\Ttypedef^\ast~\text{)}) &=&
     \bigcompose \F{idc}(\Ttypedef)^\ast \\
   \F{idc}(\text{(}~\text{type}~v^?{:}\Tid^?~\Tsubtype~\text{)}) &=&
     \{\ITYPES~(v^?), \IFIELDS~\F{idf}(\Tsubtype), \ITYPEDEFS~\X{st}\} \\
   \F{idc}(\text{(}~\text{tag}~v^?{:}\Tid^?~\dots~\text{)}) &=&
     \{\ITAGS~(v^?)\} \\
   \F{idc}(\text{(}~\text{global}~v^?{:}\Tid^?~\dots~\text{)}) &=&
     \{\IGLOBALS~(v^?)\} \\
   \F{idc}(\text{(}~\text{memory}~v^?{:}\Tid^?~\dots~\text{)}) &=&
     \{\IMEMS~(v^?)\} \\
   \F{idc}(\text{(}~\text{table}~v^?{:}\Tid^?~\dots~\text{)}) &=&
     \{\ITABLES~(v^?)\} \\
   \F{idc}(\text{(}~\text{func}~v^?{:}\Tid^?~\dots~\text{)}) &=&
     \{\IFUNCS~(v^?)\} \\
   \F{idc}(\text{(}~\text{data}~v^?{:}\Tid^?~\dots~\text{)}) &=&
     \{\IDATA~(v^?)\} \\
   \F{idc}(\text{(}~\text{elem}~v^?{:}\Tid^?~\dots~\text{)}) &=&
     \{\IELEM~(v^?)\} \\
   \F{idc}(\text{(}~\text{import}~\dots~\text{(}~\text{func}~v^?{:}\Tid^?~\dots~\text{)}~\text{)}) &=&
     \{\IFUNCS~(v^?)\} \\
   \F{idc}(\text{(}~\text{import}~\dots~\text{(}~\text{table}~v^?{:}\Tid^?~\dots~\text{)}~\text{)}) &=&
     \{\ITABLES~(v^?)\} \\
   \F{idc}(\text{(}~\text{import}~\dots~\text{(}~\text{memory}~v^?{:}\Tid^?~\dots~\text{)}~\text{)}) &=&
     \{\IMEMS~(v^?)\} \\
   \F{idc}(\text{(}~\text{import}~\dots~\text{(}~\text{global}~v^?{:}\Tid^?~\dots~\text{)}~\text{)}) &=&
     \{\IGLOBALS~(v^?)\} \\
   \F{idc}(\text{(}~\dots~\text{)}) &=&
     \{\}
   \\[2ex]
   \F{idf}(\text{(}~\text{sub}~\dots~\Tcomptype~\text{)}) &=&
     \F{idf}(\Tcomptype) \\
   \F{idf}(\text{(}~\text{struct}~\X{Tfield}^\ast~\text{)}) &=&
     \bigcompose \F{idf}(\Tfield)^\ast \\
   \F{idf}(\text{(}~\text{array}~\dots~\text{)}) &=&
     \epsilon \\
   \F{idf}(\text{(}~\text{func}~\dots~\text{)}) &=&
     \epsilon \\
   \F{idf}(\text{(}~\text{field}~v^?{:}\Tid^?~\dots~\text{)}) &=&
     v^? \\
   \end{array}


Abbreviations
.............

In a source file, the toplevel :math:`\T{(module}~\dots\T{)}` surrounding the module body may be omitted.

.. math::
   \begin{array}{llcll}
   \production{module} &
     \Tmodulefield^\ast &\equiv&
     \text{(}~\text{module}~~\Tmodulefield^\ast~\text{)}
   \end{array}
;)
