diff --git a/interpreter/binary/decode.ml b/interpreter/binary/decode.ml
index 4b158e2f9..7c67ca3c7 100644
--- a/interpreter/binary/decode.ml
+++ b/interpreter/binary/decode.ml
@@ -100,10 +100,11 @@ let rec sN n s =
   then (if b land 0x40 = 0 then x else Int64.(logor x (logxor (-1L) 0x7fL)))
   else Int64.(logor x (shift_left (sN (n - 7) s) 7))
 
-let u32 s = Int64.to_int32 (uN 32 s)
+let u8 s = I8.of_int_u (I64.to_int_u (uN 8 s))
+let u32 s = I32.of_int_u (I64.to_int_u (uN 32 s))
 let u64 s = uN 64 s
-let s7 s = Int64.to_int (sN 7 s)
-let s32 s = Int64.to_int32 (sN 32 s)
+let s7 s = I64.to_int_s (sN 7 s)
+let s32 s = I32.of_int_s (I64.to_int_s (sN 32 s))
 let s33 s = Convert.I32_.wrap_i64 (sN 33 s)
 let s64 s = sN 64 s
 let f32 s = F32.of_bits (word32 s)
@@ -120,6 +121,7 @@ let string s = let n = len32 s in get_string n s
 let rec list f n s = if n = 0 then [] else let x = f s in x :: list f (n - 1) s
 let opt f b s = if b then Some (f s) else None
 let vec f s = let n = len32 s in list f n s
+let repeat n f s = List.init n (fun _ -> f s)
 
 let rec either fs s =
   match fs with
@@ -147,6 +149,7 @@ open Types
 
 let zero s = expect 0x00 s "zero byte expected"
 let idx s = u32 s
+let laneidx s = u8 s
 
 let mutability s =
   match byte s with
@@ -384,38 +387,29 @@ let rec instr s =
 
   | 0x05 -> error s pos "misplaced ELSE opcode"
   | 0x06 | 0x07 as b -> illegal s pos b
-  | 0x08 -> throw (at idx s)
+  | 0x08 -> let x = at idx s in throw x
   | 0x09 as b -> illegal s pos b
   | 0x0a -> throw_ref
   | 0x0b -> error s pos "misplaced END opcode"
 
-  | 0x0c -> br (at idx s)
-  | 0x0d -> br_if (at idx s)
-  | 0x0e ->
-    let xs = vec (at idx) s in
-    let x = at idx s in
-    br_table xs x
+  | 0x0c -> let x = at idx s in br x
+  | 0x0d -> let x = at idx s in br_if x
+  | 0x0e -> let xs = vec (at idx) s in let x = at idx s in br_table xs x
   | 0x0f -> return
 
-  | 0x10 -> call (at idx s)
-  | 0x11 ->
-    let y = at idx s in
-    let x = at idx s in
-    call_indirect x y
-  | 0x12 -> return_call (at idx s)
-  | 0x13 ->
-    let y = at idx s in
-    let x = at idx s in
-    return_call_indirect x y
+  | 0x10 -> let x = at idx s in call x
+  | 0x11 -> let y = at idx s in let x = at idx s in call_indirect x y
+  | 0x12 -> let x = at idx s in return_call x
+  | 0x13 -> let y = at idx s in let x = at idx s in return_call_indirect x y
 
-  | 0x14 -> call_ref (at idx s)
-  | 0x15 -> return_call_ref (at idx s)
+  | 0x14 -> let x = at idx s in call_ref x
+  | 0x15 -> let x = at idx s in return_call_ref x
 
   | 0x16 | 0x17 | 0x18 | 0x19 as b -> illegal s pos b
 
   | 0x1a -> drop
   | 0x1b -> select None
-  | 0x1c -> select (Some (vec valtype s))
+  | 0x1c -> let ts = vec valtype s in select (Some ts)
 
   | 0x1d | 0x1e as b -> illegal s pos b
 
@@ -426,13 +420,13 @@ let rec instr s =
     end_ s;
     try_table bt cs es
 
-  | 0x20 -> local_get (at idx s)
-  | 0x21 -> local_set (at idx s)
-  | 0x22 -> local_tee (at idx s)
-  | 0x23 -> global_get (at idx s)
-  | 0x24 -> global_set (at idx s)
-  | 0x25 -> table_get (at idx s)
-  | 0x26 -> table_set (at idx s)
+  | 0x20 -> let x = at idx s in local_get x
+  | 0x21 -> let x = at idx s in local_set x
+  | 0x22 -> let x = at idx s in local_tee x
+  | 0x23 -> let x = at idx s in global_get x
+  | 0x24 -> let x = at idx s in global_set x
+  | 0x25 -> let x = at idx s in table_get x
+  | 0x26 -> let x = at idx s in table_set x
 
   | 0x27 as b -> illegal s pos b
 
@@ -461,13 +455,13 @@ let rec instr s =
   | 0x3d -> let x, a, o = memop s in i64_store16 x a o
   | 0x3e -> let x, a, o = memop s in i64_store32 x a o
 
-  | 0x3f -> memory_size (at idx s)
-  | 0x40 -> memory_grow (at idx s)
+  | 0x3f -> let x = at idx s in memory_size x
+  | 0x40 -> let x = at idx s in memory_grow x
 
-  | 0x41 -> i32_const (at s32 s)
-  | 0x42 -> i64_const (at s64 s)
-  | 0x43 -> f32_const (at f32 s)
-  | 0x44 -> f64_const (at f64 s)
+  | 0x41 -> let c = at s32 s in i32_const c
+  | 0x42 -> let c = at s64 s in i64_const c
+  | 0x43 -> let c = at f32 s in f32_const c
+  | 0x44 -> let c = at f64 s in f64_const c
 
   | 0x45 -> i32_eqz
   | 0x46 -> i32_eq
@@ -611,42 +605,42 @@ let rec instr s =
   | 0xc5 | 0xc6 | 0xc7 | 0xc8 | 0xc9 | 0xca | 0xcb
   | 0xcc | 0xcd | 0xce | 0xcf as b -> illegal s pos b
 
-  | 0xd0 -> ref_null (heaptype s)
+  | 0xd0 -> let ht = heaptype s in ref_null ht
   | 0xd1 -> ref_is_null
-  | 0xd2 -> ref_func (at idx s)
+  | 0xd2 -> let x = at idx s in ref_func x
   | 0xd3 -> ref_eq
   | 0xd4 -> ref_as_non_null
-  | 0xd5 -> br_on_null (at idx s)
-  | 0xd6 -> br_on_non_null (at idx s)
+  | 0xd5 -> let x = at idx s in br_on_null x
+  | 0xd6 -> let x = at idx s in br_on_non_null x
 
   | 0xfb as b ->
     (match u32 s with
-    | 0x00l -> struct_new (at idx s)
-    | 0x01l -> struct_new_default (at idx s)
-    | 0x02l -> let x = at idx s in let y = at idx s in struct_get x y
-    | 0x03l -> let x = at idx s in let y = at idx s in struct_get_s x y
-    | 0x04l -> let x = at idx s in let y = at idx s in struct_get_u x y
-    | 0x05l -> let x = at idx s in let y = at idx s in struct_set x y
-
-    | 0x06l -> array_new (at idx s)
-    | 0x07l -> array_new_default (at idx s)
+    | 0x00l -> let x = at idx s in struct_new x
+    | 0x01l -> let x = at idx s in struct_new_default x
+    | 0x02l -> let x = at idx s in let i = idx s in struct_get x i
+    | 0x03l -> let x = at idx s in let i = idx s in struct_get_s x i
+    | 0x04l -> let x = at idx s in let i = idx s in struct_get_u x i
+    | 0x05l -> let x = at idx s in let i = idx s in struct_set x i
+
+    | 0x06l -> let x = at idx s in array_new x
+    | 0x07l -> let x = at idx s in array_new_default x
     | 0x08l -> let x = at idx s in let n = u32 s in array_new_fixed x n
     | 0x09l -> let x = at idx s in let y = at idx s in array_new_data x y
     | 0x0al -> let x = at idx s in let y = at idx s in array_new_elem x y
-    | 0x0bl -> array_get (at idx s)
-    | 0x0cl -> array_get_s (at idx s)
-    | 0x0dl -> array_get_u (at idx s)
-    | 0x0el -> array_set (at idx s)
+    | 0x0bl -> let x = at idx s in array_get x
+    | 0x0cl -> let x = at idx s in array_get_s x
+    | 0x0dl -> let x = at idx s in array_get_u x
+    | 0x0el -> let x = at idx s in array_set x
     | 0x0fl -> array_len
-    | 0x10l -> array_fill (at idx s)
+    | 0x10l -> let x = at idx s in array_fill x
     | 0x11l -> let x = at idx s in let y = at idx s in array_copy x y
     | 0x12l -> let x = at idx s in let y = at idx s in array_init_data x y
     | 0x13l -> let x = at idx s in let y = at idx s in array_init_elem x y
 
-    | 0x14l -> ref_test (NoNull, heaptype s)
-    | 0x15l -> ref_test (Null, heaptype s)
-    | 0x16l -> ref_cast (NoNull, heaptype s)
-    | 0x17l -> ref_cast (Null, heaptype s)
+    | 0x14l -> let ht = heaptype s in ref_test (NoNull, ht)
+    | 0x15l -> let ht = heaptype s in ref_test (Null, ht)
+    | 0x16l -> let ht = heaptype s in ref_cast (NoNull, ht)
+    | 0x17l -> let ht = heaptype s in ref_cast (Null, ht)
     | 0x18l | 0x19l as opcode ->
       let flags = byte s in
       require (flags land 0xfc = 0) s (pos + 2) "malformed br_on_cast flags";
@@ -676,29 +670,17 @@ let rec instr s =
     | 0x06l -> i64_trunc_sat_f64_s
     | 0x07l -> i64_trunc_sat_f64_u
 
-    | 0x08l ->
-      let y = at idx s in
-      let x = at idx s in
-      memory_init x y
-    | 0x09l -> data_drop (at idx s)
-    | 0x0al ->
-      let x = at idx s in
-      let y = at idx s in
-      memory_copy x y
-    | 0x0bl -> memory_fill (at idx s)
+    | 0x08l -> let y = at idx s in let x = at idx s in memory_init x y
+    | 0x09l -> let x = at idx s in data_drop x
+    | 0x0al -> let x = at idx s in let y = at idx s in memory_copy x y
+    | 0x0bl -> let x = at idx s in memory_fill x
 
-    | 0x0cl ->
-      let y = at idx s in
-      let x = at idx s in
-      table_init x y
-    | 0x0dl -> elem_drop (at idx s)
-    | 0x0el ->
-      let x = at idx s in
-      let y = at idx s in
-      table_copy x y
-    | 0x0fl -> table_grow (at idx s)
-    | 0x10l -> table_size (at idx s)
-    | 0x11l -> table_fill (at idx s)
+    | 0x0cl -> let y = at idx s in let x = at idx s in table_init x y
+    | 0x0dl -> let x = at idx s in elem_drop x
+    | 0x0el -> let x = at idx s in let y = at idx s in table_copy x y
+    | 0x0fl -> let x = at idx s in table_grow x
+    | 0x10l -> let x = at idx s in table_size x
+    | 0x11l -> let x = at idx s in table_fill x
 
     | n -> illegal2 s pos b n
     )
@@ -717,8 +699,8 @@ let rec instr s =
     | 0x09l -> let x, a, o = memop s in v128_load32_splat x a o
     | 0x0al -> let x, a, o = memop s in v128_load64_splat x a o
     | 0x0bl -> let x, a, o = memop s in v128_store x a o
-    | 0x0cl -> v128_const (at v128 s)
-    | 0x0dl -> i8x16_shuffle (List.init 16 (fun _ -> byte s))
+    | 0x0cl -> let c = at v128 s in v128_const c
+    | 0x0dl -> let is = repeat 16 laneidx s in i8x16_shuffle is
     | 0x0el -> i8x16_swizzle
     | 0x0fl -> i8x16_splat
     | 0x10l -> i16x8_splat
@@ -726,20 +708,20 @@ let rec instr s =
     | 0x12l -> i64x2_splat
     | 0x13l -> f32x4_splat
     | 0x14l -> f64x2_splat
-    | 0x15l -> let i = byte s in i8x16_extract_lane_s i
-    | 0x16l -> let i = byte s in i8x16_extract_lane_u i
-    | 0x17l -> let i = byte s in i8x16_replace_lane i
-    | 0x18l -> let i = byte s in i16x8_extract_lane_s i
-    | 0x19l -> let i = byte s in i16x8_extract_lane_u i
-    | 0x1al -> let i = byte s in i16x8_replace_lane i
-    | 0x1bl -> let i = byte s in i32x4_extract_lane i
-    | 0x1cl -> let i = byte s in i32x4_replace_lane i
-    | 0x1dl -> let i = byte s in i64x2_extract_lane i
-    | 0x1el -> let i = byte s in i64x2_replace_lane i
-    | 0x1fl -> let i = byte s in f32x4_extract_lane i
-    | 0x20l -> let i = byte s in f32x4_replace_lane i
-    | 0x21l -> let i = byte s in f64x2_extract_lane i
-    | 0x22l -> let i = byte s in f64x2_replace_lane i
+    | 0x15l -> let i = laneidx s in i8x16_extract_lane_s i
+    | 0x16l -> let i = laneidx s in i8x16_extract_lane_u i
+    | 0x17l -> let i = laneidx s in i8x16_replace_lane i
+    | 0x18l -> let i = laneidx s in i16x8_extract_lane_s i
+    | 0x19l -> let i = laneidx s in i16x8_extract_lane_u i
+    | 0x1al -> let i = laneidx s in i16x8_replace_lane i
+    | 0x1bl -> let i = laneidx s in i32x4_extract_lane i
+    | 0x1cl -> let i = laneidx s in i32x4_replace_lane i
+    | 0x1dl -> let i = laneidx s in i64x2_extract_lane i
+    | 0x1el -> let i = laneidx s in i64x2_replace_lane i
+    | 0x1fl -> let i = laneidx s in f32x4_extract_lane i
+    | 0x20l -> let i = laneidx s in f32x4_replace_lane i
+    | 0x21l -> let i = laneidx s in f64x2_extract_lane i
+    | 0x22l -> let i = laneidx s in f64x2_replace_lane i
     | 0x23l -> i8x16_eq
     | 0x24l -> i8x16_ne
     | 0x25l -> i8x16_lt_s
@@ -790,37 +772,21 @@ let rec instr s =
     | 0x52l -> v128_bitselect
     | 0x53l -> v128_any_true
     | 0x54l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_load8_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_load8_lane x a o i
     | 0x55l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_load16_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_load16_lane x a o i
     | 0x56l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_load32_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_load32_lane x a o i
     | 0x57l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_load64_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_load64_lane x a o i
     | 0x58l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_store8_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_store8_lane x a o i
     | 0x59l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_store16_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_store16_lane x a o i
     | 0x5al ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_store32_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_store32_lane x a o i
     | 0x5bl ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_store64_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_store64_lane x a o i
     | 0x5cl -> let x, a, o = memop s in v128_load32_zero x a o
     | 0x5dl -> let x, a, o = memop s in v128_load64_zero x a o
     | 0x5el -> f32x4_demote_f64x2_zero
@@ -1011,16 +977,10 @@ and instr_block' s es =
 
 and catch s =
   match byte s with
-  | 0x00 ->
-    let x1 = at idx s in
-    let x2 = at idx s in
-    Mnemonics.catch x1 x2
-  | 0x01 ->
-    let x1 = at idx s in
-    let x2 = at idx s in
-    catch_ref x1 x2
-  | 0x02 -> catch_all (at idx s)
-  | 0x03 -> catch_all_ref (at idx s)
+  | 0x00 -> let x = at idx s in let y = at idx s in Mnemonics.catch x y
+  | 0x01 -> let x = at idx s in let y = at idx s in catch_ref x y
+  | 0x02 -> let x = at idx s in catch_all x
+  | 0x03 -> let x = at idx s in catch_all_ref x
   | _ -> error s (pos s - 1) "malformed catch clause"
 
 let const s =
@@ -1145,11 +1105,11 @@ let global_section s =
 
 let externidx s =
   match byte s with
-  | 0x00 -> FuncX (at idx s)
-  | 0x01 -> TableX (at idx s)
-  | 0x02 -> MemoryX (at idx s)
-  | 0x03 -> GlobalX (at idx s)
-  | 0x04 -> TagX (at idx s)
+  | 0x00 -> let x = at idx s in FuncX x
+  | 0x01 -> let x = at idx s in TableX x
+  | 0x02 -> let x = at idx s in MemoryX x
+  | 0x03 -> let x = at idx s in GlobalX x
+  | 0x04 -> let x = at idx s in TagX x
   | _ -> error s (pos s - 1) "malformed export kind"
 
 let export s =
@@ -1185,21 +1145,10 @@ let code_section s =
 
 (* Element section *)
 
-let passive s =
-  Passive
-
-let active s =
-  let x = at idx s in
-  let c = const s in
-  Active (x, c)
-
-let active_zero s =
-  let x = 0l @@ no_region in
-  let c = const s in
-  Active (x, c)
-
-let declarative s =
-  Declarative
+let passive s = Passive
+let active s = let x = at idx s in let c = const s in Active (x, c)
+let active_zero s = let x = 0l @@ no_region in let c = const s in Active (x, c)
+let declarative s = Declarative
 
 let elem_index s =
   let x = at idx s in
diff --git a/interpreter/binary/encode.ml b/interpreter/binary/encode.ml
index 4a470b1b9..a324ea22f 100644
--- a/interpreter/binary/encode.ml
+++ b/interpreter/binary/encode.ml
@@ -61,6 +61,7 @@ struct
     if -64L <= i && i < 64L then byte b
     else (byte (b lor 0x80); s64 (Int64.shift_right i 7))
 
+  let u8 i = u64 Int64.(logand (of_int (I8.to_int_u i)) 0xffL)
   let u32 i = u64 Int64.(logand (of_int32 i) 0xffffffffL)
   let s7 i = s64 (Int64.of_int i)
   let s32 i = s64 (Int64.of_int32 i)
@@ -394,25 +395,25 @@ struct
       error e.at "illegal instruction v128.loadNxM_x"
 
     | VecLoadLane (x, ({ty = V128T; pack = Pack8; _} as mo), i) ->
-      vecop 0x54l; memop x mo; byte i;
+      vecop 0x54l; memop x mo; u8 i;
     | VecLoadLane (x, ({ty = V128T; pack = Pack16; _} as mo), i) ->
-      vecop 0x55l; memop x mo; byte i;
+      vecop 0x55l; memop x mo; u8 i;
     | VecLoadLane (x, ({ty = V128T; pack = Pack32; _} as mo), i) ->
-      vecop 0x56l; memop x mo; byte i;
+      vecop 0x56l; memop x mo; u8 i;
     | VecLoadLane (x, ({ty = V128T; pack = Pack64; _} as mo), i) ->
-      vecop 0x57l; memop x mo; byte i;
+      vecop 0x57l; memop x mo; u8 i;
 
     | VecStore (x, ({ty = V128T; _} as mo)) ->
       vecop 0x0bl; memop x mo
 
     | VecStoreLane (x, ({ty = V128T; pack = Pack8; _} as mo), i) ->
-      vecop 0x58l; memop x mo; byte i;
+      vecop 0x58l; memop x mo; u8 i;
     | VecStoreLane (x, ({ty = V128T; pack = Pack16; _} as mo), i) ->
-      vecop 0x59l; memop x mo; byte i;
+      vecop 0x59l; memop x mo; u8 i;
     | VecStoreLane (x, ({ty = V128T; pack = Pack32; _} as mo), i) ->
-      vecop 0x5al; memop x mo; byte i;
+      vecop 0x5al; memop x mo; u8 i;
     | VecStoreLane (x, ({ty = V128T; pack = Pack64; _} as mo), i) ->
-      vecop 0x5bl; memop x mo; byte i;
+      vecop 0x5bl; memop x mo; u8 i;
 
     | MemorySize x -> op 0x3f; idx x
     | MemoryGrow x -> op 0x40; idx x
@@ -439,10 +440,10 @@ struct
 
     | StructNew (x, Explicit) -> op 0xfb; op 0x00; idx x
     | StructNew (x, Implicit) -> op 0xfb; op 0x01; idx x
-    | StructGet (x, y, None) -> op 0xfb; op 0x02; idx x; idx y
-    | StructGet (x, y, Some S) -> op 0xfb; op 0x03; idx x; idx y
-    | StructGet (x, y, Some U) -> op 0xfb; op 0x04; idx x; idx y
-    | StructSet (x, y) -> op 0xfb; op 0x05; idx x; idx y
+    | StructGet (x, i, None) -> op 0xfb; op 0x02; idx x; u32 i
+    | StructGet (x, i, Some S) -> op 0xfb; op 0x03; idx x; u32 i
+    | StructGet (x, i, Some U) -> op 0xfb; op 0x04; idx x; u32 i
+    | StructSet (x, i) -> op 0xfb; op 0x05; idx x; u32 i
 
     | ArrayNew (x, Explicit) -> op 0xfb; op 0x06; idx x
     | ArrayNew (x, Implicit) -> op 0xfb; op 0x07; idx x
@@ -728,7 +729,8 @@ struct
     | VecCompare (V128 (F64x2 V128Op.Le)) -> vecop 0x4bl
     | VecCompare (V128 (F64x2 V128Op.Ge)) -> vecop 0x4cl
 
-    | VecBinary (V128 (I8x16 (V128Op.Shuffle is))) -> vecop 0x0dl; List.iter byte is
+    | VecBinary (V128 (I8x16 (V128Op.Shuffle is))) ->
+      vecop 0x0dl; List.iter u8 is
     | VecBinary (V128 (I8x16 V128Op.Swizzle)) -> vecop 0x0el
     | VecBinary (V128 (I8x16 V128Op.(Narrow S))) -> vecop 0x65l
     | VecBinary (V128 (I8x16 V128Op.(Narrow U))) -> vecop 0x66l
@@ -895,21 +897,21 @@ struct
     | VecSplat (V128 ((F32x4 V128Op.Splat))) -> vecop 0x13l
     | VecSplat (V128 ((F64x2 V128Op.Splat))) -> vecop 0x14l
 
-    | VecExtract (V128 (I8x16 V128Op.(Extract (i, S)))) -> vecop 0x15l; byte i
-    | VecExtract (V128 (I8x16 V128Op.(Extract (i, U)))) -> vecop 0x16l; byte i
-    | VecExtract (V128 (I16x8 V128Op.(Extract (i, S)))) -> vecop 0x18l; byte i
-    | VecExtract (V128 (I16x8 V128Op.(Extract (i, U)))) -> vecop 0x19l; byte i
-    | VecExtract (V128 (I32x4 V128Op.(Extract (i, ())))) -> vecop 0x1bl; byte i
-    | VecExtract (V128 (I64x2 V128Op.(Extract (i, ())))) -> vecop 0x1dl; byte i
-    | VecExtract (V128 (F32x4 V128Op.(Extract (i, ())))) -> vecop 0x1fl; byte i
-    | VecExtract (V128 (F64x2 V128Op.(Extract (i, ())))) -> vecop 0x21l; byte i
-
-    | VecReplace (V128 (I8x16 V128Op.(Replace i))) -> vecop 0x17l; byte i
-    | VecReplace (V128 (I16x8 V128Op.(Replace i))) -> vecop 0x1al; byte i
-    | VecReplace (V128 (I32x4 V128Op.(Replace i))) -> vecop 0x1cl; byte i
-    | VecReplace (V128 (I64x2 V128Op.(Replace i))) -> vecop 0x1el; byte i
-    | VecReplace (V128 (F32x4 V128Op.(Replace i))) -> vecop 0x20l; byte i
-    | VecReplace (V128 (F64x2 V128Op.(Replace i))) -> vecop 0x22l; byte i
+    | VecExtract (V128 (I8x16 V128Op.(Extract (i, S)))) -> vecop 0x15l; u8 i
+    | VecExtract (V128 (I8x16 V128Op.(Extract (i, U)))) -> vecop 0x16l; u8 i
+    | VecExtract (V128 (I16x8 V128Op.(Extract (i, S)))) -> vecop 0x18l; u8 i
+    | VecExtract (V128 (I16x8 V128Op.(Extract (i, U)))) -> vecop 0x19l; u8 i
+    | VecExtract (V128 (I32x4 V128Op.(Extract (i, ())))) -> vecop 0x1bl; u8 i
+    | VecExtract (V128 (I64x2 V128Op.(Extract (i, ())))) -> vecop 0x1dl; u8 i
+    | VecExtract (V128 (F32x4 V128Op.(Extract (i, ())))) -> vecop 0x1fl; u8 i
+    | VecExtract (V128 (F64x2 V128Op.(Extract (i, ())))) -> vecop 0x21l; u8 i
+
+    | VecReplace (V128 (I8x16 V128Op.(Replace i))) -> vecop 0x17l; u8 i
+    | VecReplace (V128 (I16x8 V128Op.(Replace i))) -> vecop 0x1al; u8 i
+    | VecReplace (V128 (I32x4 V128Op.(Replace i))) -> vecop 0x1cl; u8 i
+    | VecReplace (V128 (I64x2 V128Op.(Replace i))) -> vecop 0x1el; u8 i
+    | VecReplace (V128 (F32x4 V128Op.(Replace i))) -> vecop 0x20l; u8 i
+    | VecReplace (V128 (F64x2 V128Op.(Replace i))) -> vecop 0x22l; u8 i
 
   and catch c =
     match c.it with
diff --git a/interpreter/exec/eval.ml b/interpreter/exec/eval.ml
index 49d5f0275..555f85caa 100644
--- a/interpreter/exec/eval.ml
+++ b/interpreter/exec/eval.ml
@@ -499,17 +499,17 @@ let rec step (c : config) : config =
           let v =
             match pack with
             | Pack8 ->
-              V128.I8x16.replace_lane j v
-                (I32Num.of_num 0 (Memory.load_num_packed Pack8 S mem i_64 offset I32T))
+              let num = Memory.load_num_packed Pack8 S mem i_64 offset I32T in
+              V128.I8x16.replace_lane j v (I32Num.of_num 0 num)
             | Pack16 ->
-              V128.I16x8.replace_lane j v
-                (I32Num.of_num 0 (Memory.load_num_packed Pack16 S mem i_64 offset I32T))
+              let num = Memory.load_num_packed Pack16 S mem i_64 offset I32T in
+              V128.I16x8.replace_lane j v (I32Num.of_num 0 num)
             | Pack32 ->
-              V128.I32x4.replace_lane j v
-                (I32Num.of_num 0 (Memory.load_num mem i_64 offset I32T))
+              let num = Memory.load_num mem i_64 offset I32T in
+              V128.I32x4.replace_lane j v (I32Num.of_num 0 num)
             | Pack64 ->
-              V128.I64x2.replace_lane j v
-                (I64Num.of_num 0 (Memory.load_num mem i_64 offset I64T))
+              let num = Memory.load_num mem i_64 offset I64T in
+              V128.I64x2.replace_lane j v (I64Num.of_num 0 num)
           in Vec (V128 v) :: vs', []
         with exn -> vs', [Trapping (memory_error e.at exn) @@ e.at])
 
@@ -519,13 +519,17 @@ let rec step (c : config) : config =
         (try
           (match pack with
           | Pack8 ->
-            Memory.store_num_packed Pack8 mem i_64 offset (I32 (V128.I8x16.extract_lane_s j v))
+            let num = I32 (V128.I8x16.extract_lane_s j v) in
+            Memory.store_num_packed Pack8 mem i_64 offset num
           | Pack16 ->
-            Memory.store_num_packed Pack16 mem i_64 offset (I32 (V128.I16x8.extract_lane_s j v))
+            let num = I32 (V128.I16x8.extract_lane_s j v) in
+            Memory.store_num_packed Pack16 mem i_64 offset num
           | Pack32 ->
-            Memory.store_num mem i_64 offset (I32 (V128.I32x4.extract_lane_s j v))
+            let num = I32 (V128.I32x4.extract_lane_s j v) in
+            Memory.store_num mem i_64 offset num
           | Pack64 ->
-            Memory.store_num mem i_64 offset (I64 (V128.I64x2.extract_lane_s j v))
+            let num = I64 (V128.I64x2.extract_lane_s j v) in
+            Memory.store_num mem i_64 offset num
           );
           vs', []
         with exn -> vs', [Trapping (memory_error e.at exn) @@ e.at])
@@ -684,24 +688,24 @@ let rec step (c : config) : config =
           with Failure _ -> Crash.error e.at "type mismatch packing value"
         in Ref (Aggr.StructRef struct_) :: vs'', []
 
-      | StructGet (x, y, exto), Ref (NullRef _) :: vs' ->
+      | StructGet (x, i, exto), Ref (NullRef _) :: vs' ->
         vs', [Trapping "null structure reference" @@ e.at]
 
-      | StructGet (x, y, exto), Ref Aggr.(StructRef (Struct (_, fs))) :: vs' ->
+      | StructGet (x, i, exto), Ref Aggr.(StructRef (Struct (_, fs))) :: vs' ->
         let f =
-          try Lib.List32.nth fs y.it
-          with Failure _ -> Crash.error y.at "undefined field"
+          try Lib.List32.nth fs i
+          with Failure _ -> Crash.error e.at "undefined field"
         in
         (try Aggr.read_field f exto :: vs', []
         with Failure _ -> Crash.error e.at "type mismatch reading field")
 
-      | StructSet (x, y), v :: Ref (NullRef _) :: vs' ->
+      | StructSet (x, i), v :: Ref (NullRef _) :: vs' ->
         vs', [Trapping "null structure reference" @@ e.at]
 
-      | StructSet (x, y), v :: Ref Aggr.(StructRef (Struct (_, fs))) :: vs' ->
+      | StructSet (x, i), v :: Ref Aggr.(StructRef (Struct (_, fs))) :: vs' ->
         let f =
-          try Lib.List32.nth fs y.it
-          with Failure _ -> Crash.error y.at "undefined field"
+          try Lib.List32.nth fs i
+          with Failure _ -> Crash.error e.at "undefined field"
         in
         (try Aggr.write_field f v; vs', []
         with Failure _ -> Crash.error e.at "type mismatch writing field")
diff --git a/interpreter/exec/v128.mli b/interpreter/exec/v128.mli
index 89262dc4d..a763d1419 100644
--- a/interpreter/exec/v128.mli
+++ b/interpreter/exec/v128.mli
@@ -128,7 +128,7 @@ module F64x2 : FloatShape with type lane = F64.t
 
 module V1x128 :
 sig
-  val lognot : t -> t
+  val not_ : t -> t
   val and_ : t -> t -> t
   val or_ : t -> t -> t
   val xor : t -> t -> t
diff --git a/interpreter/syntax/ast.ml b/interpreter/syntax/ast.ml
index 183241cba..bd5f145ea 100644
--- a/interpreter/syntax/ast.ml
+++ b/interpreter/syntax/ast.ml
@@ -61,6 +61,7 @@ module F64Op = FloatOp
 
 module V128Op =
 struct
+  type laneidx = I8.t
   type half = Low | High
 
   type iunop = Abs | Neg | Popcnt
@@ -68,7 +69,7 @@ struct
   type ibinop = Add | Sub | Mul | Min of sx | Max of sx | AvgrU
               | AddSat of sx | SubSat of sx | DotS | Q15MulRSatS
               | ExtMul of half * sx
-              | Swizzle | Shuffle of int list | Narrow of sx
+              | Swizzle | Shuffle of laneidx list | Narrow of sx
               | RelaxedSwizzle | RelaxedQ15MulRS | RelaxedDot
   type fbinop = Add | Sub | Mul | Div | Min | Max | Pmin | Pmax
               | RelaxedMin | RelaxedMax
@@ -100,8 +101,8 @@ struct
   type bitmaskop = (ibitmaskop, ibitmaskop, ibitmaskop, ibitmaskop, void, void) V128.laneop
 
   type nsplatop = Splat
-  type 'a nextractop = Extract of int * 'a
-  type nreplaceop = Replace of int
+  type 'a nextractop = Extract of laneidx * 'a
+  type nreplaceop = Replace of laneidx
 
   type splatop = (nsplatop, nsplatop, nsplatop, nsplatop, nsplatop, nsplatop) V128.laneop
   type extractop = (sx nextractop, sx nextractop, unit nextractop, unit nextractop, unit nextractop, unit nextractop) V128.laneop
@@ -144,117 +145,130 @@ type externop = Internalize | Externalize
 
 (* Expressions *)
 
-type idx = int32 Source.phrase
+type idx = I32.t Source.phrase
+type typeidx = idx
+type tagidx = idx
+type globalidx = idx
+type memoryidx = idx
+type tableidx = idx
+type funcidx = idx
+type dataidx = idx
+type elemidx = idx
+type localidx = idx
+type labelidx = idx
+type fieldidx = I32.t
+type laneidx = I8.t
+
 type num = Value.num Source.phrase
 type vec = Value.vec Source.phrase
 type name = Utf8.unicode
 
-type blocktype = VarBlockType of idx | ValBlockType of valtype option
+type blocktype = VarBlockType of typeidx | ValBlockType of valtype option
 
 type instr = instr' Source.phrase
 and instr' =
-  | Unreachable                       (* trap unconditionally *)
-  | Nop                               (* do nothing *)
-  | Drop                              (* forget a value *)
-  | Select of valtype list option     (* branchless conditional *)
-  | Block of blocktype * instr list   (* execute in sequence *)
-  | Loop of blocktype * instr list    (* loop header *)
+  | Unreachable                          (* trap unconditionally *)
+  | Nop                                  (* do nothing *)
+  | Drop                                 (* forget a value *)
+  | Select of valtype list option        (* branchless conditional *)
+  | Block of blocktype * instr list      (* execute in sequence *)
+  | Loop of blocktype * instr list       (* loop header *)
   | If of blocktype * instr list * instr list   (* conditional *)
-  | Br of idx                         (* break to n-th surrounding label *)
-  | BrIf of idx                       (* conditional break *)
-  | BrTable of idx list * idx         (* indexed break *)
-  | BrOnNull of idx                   (* break on type *)
-  | BrOnNonNull of idx                (* break on type inverted *)
-  | BrOnCast of idx * reftype * reftype     (* break on type *)
-  | BrOnCastFail of idx * reftype * reftype (* break on type inverted *)
-  | Return                            (* break from function body *)
-  | Call of idx                       (* call function *)
-  | CallRef of idx                    (* call function through reference *)
-  | CallIndirect of idx * idx         (* call function through table *)
-  | ReturnCall of idx                 (* tail-call function *)
-  | ReturnCallRef of idx              (* tail call through reference *)
-  | ReturnCallIndirect of idx * idx   (* tail-call function through table *)
-  | Throw of idx                      (* throw exception *)
-  | ThrowRef                          (* rethrow exception *)
+  | Br of labelidx                       (* break to n-th surrounding label *)
+  | BrIf of labelidx                     (* conditional break *)
+  | BrTable of labelidx list * labelidx  (* indexed break *)
+  | BrOnNull of labelidx                 (* break on type *)
+  | BrOnNonNull of labelidx              (* break on type inverted *)
+  | BrOnCast of labelidx * reftype * reftype     (* break on type *)
+  | BrOnCastFail of labelidx * reftype * reftype (* break on type inverted *)
+  | Return                               (* break from function body *)
+  | Call of funcidx                      (* call function *)
+  | CallRef of typeidx                   (* call function through reference *)
+  | CallIndirect of tableidx * typeidx   (* call function through table *)
+  | ReturnCall of funcidx                (* tail-call function *)
+  | ReturnCallRef of typeidx             (* tail call through reference *)
+  | ReturnCallIndirect of tableidx * typeidx   (* tail-call function through table *)
+  | Throw of tagidx                      (* throw exception *)
+  | ThrowRef                            (* rethrow exception *)
   | TryTable of blocktype * catch list * instr list  (* handle exceptions *)
-  | LocalGet of idx                   (* read local idxiable *)
-  | LocalSet of idx                   (* write local idxiable *)
-  | LocalTee of idx                   (* write local idxiable and keep value *)
-  | GlobalGet of idx                  (* read global idxiable *)
-  | GlobalSet of idx                  (* write global idxiable *)
-  | TableGet of idx                   (* read table element *)
-  | TableSet of idx                   (* write table element *)
-  | TableSize of idx                  (* size of table *)
-  | TableGrow of idx                  (* grow table *)
-  | TableFill of idx                  (* fill table with unique value *)
-  | TableCopy of idx * idx            (* copy table range *)
-  | TableInit of idx * idx            (* initialize table range from segment *)
-  | ElemDrop of idx                   (* drop passive element segment *)
-  | Load of idx * loadop              (* read memory at address *)
-  | Store of idx * storeop            (* write memory at address *)
-  | VecLoad of idx * vloadop          (* read memory at address *)
-  | VecStore of idx * vstoreop        (* write memory at address *)
-  | VecLoadLane of idx * vlaneop * int  (* read single lane at address *)
-  | VecStoreLane of idx * vlaneop * int (* write single lane to address *)
-  | MemorySize of idx                 (* size of memory *)
-  | MemoryGrow of idx                 (* grow memory *)
-  | MemoryFill of idx                 (* fill memory range with value *)
-  | MemoryCopy of idx * idx           (* copy memory ranges *)
-  | MemoryInit of idx * idx           (* initialize memory range from segment *)
-  | DataDrop of idx                   (* drop passive data segment *)
-  | Const of num                      (* constant *)
-  | Test of testop                    (* numeric test *)
-  | Compare of relop                  (* numeric comparison *)
-  | Unary of unop                     (* unary numeric operator *)
-  | Binary of binop                   (* binary numeric operator *)
-  | Convert of cvtop                  (* conversion *)
-  | RefNull of heaptype               (* null reference *)
-  | RefFunc of idx                    (* function reference *)
-  | RefIsNull                         (* type test *)
-  | RefAsNonNull                      (* type cast *)
-  | RefTest of reftype                (* type test *)
-  | RefCast of reftype                (* type cast *)
-  | RefEq                             (* reference equality *)
-  | RefI31                            (* scalar reference *)
-  | I31Get of sx                      (* read scalar *)
-  | StructNew of idx * initop         (* allocate structure *)
-  | StructGet of idx * idx * sx option  (* read structure field *)
-  | StructSet of idx * idx            (* write structure field *)
-  | ArrayNew of idx * initop          (* allocate array *)
-  | ArrayNewFixed of idx * int32      (* allocate fixed array *)
-  | ArrayNewElem of idx * idx         (* allocate array from element segment *)
-  | ArrayNewData of idx * idx         (* allocate array from data segment *)
-  | ArrayGet of idx * sx option       (* read array slot *)
-  | ArraySet of idx                   (* write array slot *)
-  | ArrayLen                          (* read array length *)
-  | ArrayCopy of idx * idx            (* copy between two arrays *)
-  | ArrayFill of idx                  (* fill array with value *)
-  | ArrayInitData of idx * idx        (* fill array from data segment *)
-  | ArrayInitElem of idx * idx        (* fill array from elem segment *)
-  | ExternConvert of externop         (* extern conversion *)
-  | VecConst of vec                   (* constant *)
-  | VecTest of vtestop                (* vector test *)
-  | VecCompare of vrelop              (* vector comparison *)
-  | VecUnary of vunop                 (* unary vector operator *)
-  | VecBinary of vbinop               (* binary vector operator *)
-  | VecTernary of vternop             (* ternary vector operator *)
-  | VecConvert of vcvtop              (* vector conversion *)
-  | VecShift of vshiftop              (* vector shifts *)
-  | VecBitmask of vbitmaskop          (* vector masking *)
-  | VecTestBits of vvtestop           (* vector bit test *)
-  | VecUnaryBits of vvunop            (* unary bit vector operator *)
-  | VecBinaryBits of vvbinop          (* binary bit vector operator *)
-  | VecTernaryBits of vvternop        (* ternary bit vector operator *)
-  | VecSplat of vsplatop              (* number to vector conversion *)
-  | VecExtract of vextractop          (* extract lane from vector *)
-  | VecReplace of vreplaceop          (* replace lane in vector *)
+  | LocalGet of localidx                 (* read local variable *)
+  | LocalSet of localidx                 (* write local variable *)
+  | LocalTee of localidx                 (* write local variable & keep value *)
+  | GlobalGet of globalidx               (* read global variable *)
+  | GlobalSet of globalidx               (* write global variable *)
+  | TableGet of tableidx                 (* read table element *)
+  | TableSet of tableidx                 (* write table element *)
+  | TableSize of tableidx                (* size of table *)
+  | TableGrow of tableidx                (* grow table *)
+  | TableFill of tableidx                (* fill table with unique value *)
+  | TableCopy of tableidx * tableidx     (* copy table range *)
+  | TableInit of tableidx * elemidx      (* initialize table range from elems *)
+  | ElemDrop of elemidx                  (* drop passive element segment *)
+  | Load of memoryidx * loadop           (* read memory at address *)
+  | Store of memoryidx * storeop         (* write memory at address *)
+  | VecLoad of memoryidx * vloadop       (* read memory at address *)
+  | VecStore of memoryidx * vstoreop     (* write memory at address *)
+  | VecLoadLane of memoryidx * vlaneop * laneidx  (* read single lane at address *)
+  | VecStoreLane of memoryidx * vlaneop * laneidx (* write single lane to address *)
+  | MemorySize of memoryidx              (* size of memory *)
+  | MemoryGrow of memoryidx              (* grow memory *)
+  | MemoryFill of memoryidx              (* fill memory range with value *)
+  | MemoryCopy of memoryidx * memoryidx  (* copy memory ranges *)
+  | MemoryInit of memoryidx * dataidx    (* initialize memory range from data *)
+  | DataDrop of dataidx                  (* drop passive data segment *)
+  | Const of num                         (* constant *)
+  | Test of testop                       (* numeric test *)
+  | Compare of relop                     (* numeric comparison *)
+  | Unary of unop                        (* unary numeric operator *)
+  | Binary of binop                      (* binary numeric operator *)
+  | Convert of cvtop                     (* conversion *)
+  | RefNull of heaptype                  (* null reference *)
+  | RefFunc of funcidx                   (* function reference *)
+  | RefIsNull                            (* type test *)
+  | RefAsNonNull                         (* type cast *)
+  | RefTest of reftype                   (* type test *)
+  | RefCast of reftype                   (* type cast *)
+  | RefEq                                (* reference equality *)
+  | RefI31                               (* scalar reference *)
+  | I31Get of sx                         (* read scalar *)
+  | StructNew of typeidx * initop        (* allocate structure *)
+  | StructGet of typeidx * fieldidx * sx option  (* read structure field *)
+  | StructSet of typeidx * fieldidx      (* write structure field *)
+  | ArrayNew of typeidx * initop         (* allocate array *)
+  | ArrayNewFixed of typeidx * int32     (* allocate fixed array *)
+  | ArrayNewData of typeidx * dataidx    (* allocate array from data *)
+  | ArrayNewElem of typeidx * elemidx    (* allocate array from elements *)
+  | ArrayGet of typeidx * sx option      (* read array slot *)
+  | ArraySet of typeidx                  (* write array slot *)
+  | ArrayLen                             (* read array length *)
+  | ArrayCopy of typeidx * typeidx       (* copy between two arrays *)
+  | ArrayFill of typeidx                 (* fill array with value *)
+  | ArrayInitData of typeidx * dataidx   (* fill array from data segment *)
+  | ArrayInitElem of typeidx * elemidx   (* fill array from elem segment *)
+  | ExternConvert of externop            (* extern conversion *)
+  | VecConst of vec                      (* constant *)
+  | VecTest of vtestop                   (* vector test *)
+  | VecCompare of vrelop                 (* vector comparison *)
+  | VecUnary of vunop                    (* unary vector operator *)
+  | VecBinary of vbinop                  (* binary vector operator *)
+  | VecTernary of vternop                (* ternary vector operator *)
+  | VecConvert of vcvtop                 (* vector conversion *)
+  | VecShift of vshiftop                 (* vector shifts *)
+  | VecBitmask of vbitmaskop             (* vector masking *)
+  | VecTestBits of vvtestop              (* vector bit test *)
+  | VecUnaryBits of vvunop               (* unary bit vector operator *)
+  | VecBinaryBits of vvbinop             (* binary bit vector operator *)
+  | VecTernaryBits of vvternop           (* ternary bit vector operator *)
+  | VecSplat of vsplatop                 (* number to vector conversion *)
+  | VecExtract of vextractop             (* extract lane from vector *)
+  | VecReplace of vreplaceop             (* replace lane in vector *)
 
 and catch = catch' Source.phrase
 and catch' =
-  | Catch of idx * idx
-  | CatchRef of idx * idx
-  | CatchAll of idx
-  | CatchAllRef of idx
+  | Catch of tagidx * labelidx
+  | CatchRef of tagidx * labelidx
+  | CatchAll of tagidx
+  | CatchAllRef of tagidx
 
 
 (* Modules *)
@@ -285,7 +299,7 @@ and local' =
 
 type func = func' Source.phrase
 and func' =
-  | Func of idx * local list * instr list
+  | Func of typeidx * local list * instr list
 
 type segmentmode = segmentmode' Source.phrase
 and segmentmode' =
@@ -303,15 +317,15 @@ and elem' =
 
 type start = start' Source.phrase
 and start' =
-  | Start of idx
+  | Start of funcidx
 
 type externidx = externidx' Source.phrase
 and externidx' =
-  | TagX of idx
-  | GlobalX of idx
-  | MemoryX of idx
-  | TableX of idx
-  | FuncX of idx
+  | TagX of tagidx
+  | GlobalX of globalidx
+  | MemoryX of memoryidx
+  | TableX of tableidx
+  | FuncX of funcidx
 
 type export = export' Source.phrase
 and export' =
diff --git a/interpreter/text/arrange.ml b/interpreter/text/arrange.ml
index 74efb7d00..e8e3a5d52 100644
--- a/interpreter/text/arrange.ml
+++ b/interpreter/text/arrange.ml
@@ -561,9 +561,9 @@ let rec instr e =
     | RefI31 -> "ref.i31", []
     | I31Get sx -> "i31.get" ^ ext sx, []
     | StructNew (x, op) -> "struct.new" ^ initop op ^ " " ^ idx x, []
-    | StructGet (x, y, sxo) ->
-      "struct.get" ^ opt_s ext sxo ^ " " ^ idx x ^ " " ^ idx y, []
-    | StructSet (x, y) -> "struct.set " ^ idx x ^ " " ^ idx y, []
+    | StructGet (x, i, sxo) ->
+      "struct.get" ^ opt_s ext sxo ^ " " ^ idx x ^ " " ^ nat32 i, []
+    | StructSet (x, i) -> "struct.set " ^ idx x ^ " " ^ nat32 i, []
     | ArrayNew (x, op) -> "array.new" ^ initop op ^ " " ^ idx x, []
     | ArrayNewFixed (x, n) -> "array.new_fixed " ^ idx x ^ " " ^ nat32 n, []
     | ArrayNewElem (x, y) -> "array.new_elem " ^ idx x ^ " " ^ idx y, []
diff --git a/interpreter/text/parser.mly b/interpreter/text/parser.mly
index 96b3fed20..14acfc6b5 100644
--- a/interpreter/text/parser.mly
+++ b/interpreter/text/parser.mly
@@ -310,7 +310,7 @@ let parse_annots (m : module_) : Custom.section list =
 %token<Ast.instr'> I31_GET
 %token<Ast.idx -> Ast.instr'> STRUCT_NEW ARRAY_NEW ARRAY_GET
 %token STRUCT_SET
-%token<Ast.idx -> Ast.idx -> Ast.instr'> STRUCT_GET
+%token<Ast.idx -> int32 -> Ast.instr'> STRUCT_GET
 %token ARRAY_NEW_FIXED ARRAY_NEW_ELEM ARRAY_NEW_DATA
 %token ARRAY_SET ARRAY_LEN
 %token ARRAY_COPY ARRAY_FILL ARRAY_INIT_DATA ARRAY_INIT_ELEM
@@ -623,8 +623,8 @@ plain_instr :
   | REF_I31 { fun c -> ref_i31 }
   | I31_GET { fun c -> $1 }
   | STRUCT_NEW idx { fun c -> $1 ($2 c type_) }
-  | STRUCT_GET idx idx { fun c -> let x = $2 c type_ in $1 x ($3 c (field x.it)) }
-  | STRUCT_SET idx idx { fun c -> let x = $2 c type_ in struct_set x ($3 c (field x.it)) }
+  | STRUCT_GET idx idx { fun c -> let x = $2 c type_ in $1 x ($3 c (field x.it)).it }
+  | STRUCT_SET idx idx { fun c -> let x = $2 c type_ in struct_set x ($3 c (field x.it)).it }
   | ARRAY_NEW idx { fun c -> $1 ($2 c type_) }
   | ARRAY_NEW_FIXED idx nat32 { fun c -> array_new_fixed ($2 c type_) $3 }
   | ARRAY_NEW_ELEM idx idx { fun c -> array_new_elem ($2 c type_) ($3 c elem) }
diff --git a/interpreter/valid/valid.ml b/interpreter/valid/valid.ml
index 5e4162b0e..aa92bba09 100644
--- a/interpreter/valid/valid.ml
+++ b/interpreter/valid/valid.ml
@@ -764,22 +764,22 @@ let rec check_instr (c : context) (e : instr) (s : infer_resulttype) : infer_ins
     let ts = if initop = Implicit then [] else List.map unpacked_fieldtype fts in
     ts --> [RefT (NoNull, UseHT (Def (type_ c x)))], []
 
-  | StructGet (x, y, exto) ->
+  | StructGet (x, i, exto) ->
     let StructT fts = struct_type c x in
-    require (y.it < Lib.List32.length fts) y.at
-      ("unknown field " ^ I32.to_string_u y.it);
-    let FieldT (_mut, st) = Lib.List32.nth fts y.it in
-    require ((exto <> None) == is_packed_storagetype st) y.at
+    require (i < Lib.List32.length fts) e.at
+      ("unknown field " ^ I32.to_string_u i);
+    let FieldT (_mut, st) = Lib.List32.nth fts i in
+    require ((exto <> None) == is_packed_storagetype st) e.at
       ("field is " ^ (if exto = None then "packed" else "unpacked"));
     let t = unpacked_storagetype st in
     [RefT (Null, UseHT (Def (type_ c x)))] --> [t], []
 
-  | StructSet (x, y) ->
+  | StructSet (x, i) ->
     let StructT fts = struct_type c x in
-    require (y.it < Lib.List32.length fts) y.at
-      ("unknown field " ^ I32.to_string_u y.it);
-    let FieldT (mut, st) = Lib.List32.nth fts y.it in
-    require (mut == Var) y.at "field is immutable";
+    require (i < Lib.List32.length fts) e.at
+      ("unknown field " ^ I32.to_string_u i);
+    let FieldT (mut, st) = Lib.List32.nth fts i in
+    require (mut == Var) e.at "field is immutable";
     let t = unpacked_storagetype st in
     [RefT (Null, UseHT (Def (type_ c x))); t] --> [], []
 
