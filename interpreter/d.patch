diff --git a/interpreter/binary/decode.ml b/interpreter/binary/decode.ml
index 4b158e2f9..7c67ca3c7 100644
--- a/interpreter/binary/decode.ml
+++ b/interpreter/binary/decode.ml
@@ -100,10 +100,11 @@ let rec sN n s =
   then (if b land 0x40 = 0 then x else Int64.(logor x (logxor (-1L) 0x7fL)))
   else Int64.(logor x (shift_left (sN (n - 7) s) 7))
 
-let u32 s = Int64.to_int32 (uN 32 s)
+let u8 s = I8.of_int_u (I64.to_int_u (uN 8 s))
+let u32 s = I32.of_int_u (I64.to_int_u (uN 32 s))
 let u64 s = uN 64 s
-let s7 s = Int64.to_int (sN 7 s)
-let s32 s = Int64.to_int32 (sN 32 s)
+let s7 s = I64.to_int_s (sN 7 s)
+let s32 s = I32.of_int_s (I64.to_int_s (sN 32 s))
 let s33 s = Convert.I32_.wrap_i64 (sN 33 s)
 let s64 s = sN 64 s
 let f32 s = F32.of_bits (word32 s)
@@ -120,6 +121,7 @@ let string s = let n = len32 s in get_string n s
 let rec list f n s = if n = 0 then [] else let x = f s in x :: list f (n - 1) s
 let opt f b s = if b then Some (f s) else None
 let vec f s = let n = len32 s in list f n s
+let repeat n f s = List.init n (fun _ -> f s)
 
 let rec either fs s =
   match fs with
@@ -147,6 +149,7 @@ open Types
 
 let zero s = expect 0x00 s "zero byte expected"
 let idx s = u32 s
+let laneidx s = u8 s
 
 let mutability s =
   match byte s with
@@ -384,38 +387,29 @@ let rec instr s =
 
   | 0x05 -> error s pos "misplaced ELSE opcode"
   | 0x06 | 0x07 as b -> illegal s pos b
-  | 0x08 -> throw (at idx s)
+  | 0x08 -> let x = at idx s in throw x
   | 0x09 as b -> illegal s pos b
   | 0x0a -> throw_ref
   | 0x0b -> error s pos "misplaced END opcode"
 
-  | 0x0c -> br (at idx s)
-  | 0x0d -> br_if (at idx s)
-  | 0x0e ->
-    let xs = vec (at idx) s in
-    let x = at idx s in
-    br_table xs x
+  | 0x0c -> let x = at idx s in br x
+  | 0x0d -> let x = at idx s in br_if x
+  | 0x0e -> let xs = vec (at idx) s in let x = at idx s in br_table xs x
   | 0x0f -> return
 
-  | 0x10 -> call (at idx s)
-  | 0x11 ->
-    let y = at idx s in
-    let x = at idx s in
-    call_indirect x y
-  | 0x12 -> return_call (at idx s)
-  | 0x13 ->
-    let y = at idx s in
-    let x = at idx s in
-    return_call_indirect x y
+  | 0x10 -> let x = at idx s in call x
+  | 0x11 -> let y = at idx s in let x = at idx s in call_indirect x y
+  | 0x12 -> let x = at idx s in return_call x
+  | 0x13 -> let y = at idx s in let x = at idx s in return_call_indirect x y
 
-  | 0x14 -> call_ref (at idx s)
-  | 0x15 -> return_call_ref (at idx s)
+  | 0x14 -> let x = at idx s in call_ref x
+  | 0x15 -> let x = at idx s in return_call_ref x
 
   | 0x16 | 0x17 | 0x18 | 0x19 as b -> illegal s pos b
 
   | 0x1a -> drop
   | 0x1b -> select None
-  | 0x1c -> select (Some (vec valtype s))
+  | 0x1c -> let ts = vec valtype s in select (Some ts)
 
   | 0x1d | 0x1e as b -> illegal s pos b
 
@@ -426,13 +420,13 @@ let rec instr s =
     end_ s;
     try_table bt cs es
 
-  | 0x20 -> local_get (at idx s)
-  | 0x21 -> local_set (at idx s)
-  | 0x22 -> local_tee (at idx s)
-  | 0x23 -> global_get (at idx s)
-  | 0x24 -> global_set (at idx s)
-  | 0x25 -> table_get (at idx s)
-  | 0x26 -> table_set (at idx s)
+  | 0x20 -> let x = at idx s in local_get x
+  | 0x21 -> let x = at idx s in local_set x
+  | 0x22 -> let x = at idx s in local_tee x
+  | 0x23 -> let x = at idx s in global_get x
+  | 0x24 -> let x = at idx s in global_set x
+  | 0x25 -> let x = at idx s in table_get x
+  | 0x26 -> let x = at idx s in table_set x
 
   | 0x27 as b -> illegal s pos b
 
@@ -461,13 +455,13 @@ let rec instr s =
   | 0x3d -> let x, a, o = memop s in i64_store16 x a o
   | 0x3e -> let x, a, o = memop s in i64_store32 x a o
 
-  | 0x3f -> memory_size (at idx s)
-  | 0x40 -> memory_grow (at idx s)
+  | 0x3f -> let x = at idx s in memory_size x
+  | 0x40 -> let x = at idx s in memory_grow x
 
-  | 0x41 -> i32_const (at s32 s)
-  | 0x42 -> i64_const (at s64 s)
-  | 0x43 -> f32_const (at f32 s)
-  | 0x44 -> f64_const (at f64 s)
+  | 0x41 -> let c = at s32 s in i32_const c
+  | 0x42 -> let c = at s64 s in i64_const c
+  | 0x43 -> let c = at f32 s in f32_const c
+  | 0x44 -> let c = at f64 s in f64_const c
 
   | 0x45 -> i32_eqz
   | 0x46 -> i32_eq
@@ -611,42 +605,42 @@ let rec instr s =
   | 0xc5 | 0xc6 | 0xc7 | 0xc8 | 0xc9 | 0xca | 0xcb
   | 0xcc | 0xcd | 0xce | 0xcf as b -> illegal s pos b
 
-  | 0xd0 -> ref_null (heaptype s)
+  | 0xd0 -> let ht = heaptype s in ref_null ht
   | 0xd1 -> ref_is_null
-  | 0xd2 -> ref_func (at idx s)
+  | 0xd2 -> let x = at idx s in ref_func x
   | 0xd3 -> ref_eq
   | 0xd4 -> ref_as_non_null
-  | 0xd5 -> br_on_null (at idx s)
-  | 0xd6 -> br_on_non_null (at idx s)
+  | 0xd5 -> let x = at idx s in br_on_null x
+  | 0xd6 -> let x = at idx s in br_on_non_null x
 
   | 0xfb as b ->
     (match u32 s with
-    | 0x00l -> struct_new (at idx s)
-    | 0x01l -> struct_new_default (at idx s)
-    | 0x02l -> let x = at idx s in let y = at idx s in struct_get x y
-    | 0x03l -> let x = at idx s in let y = at idx s in struct_get_s x y
-    | 0x04l -> let x = at idx s in let y = at idx s in struct_get_u x y
-    | 0x05l -> let x = at idx s in let y = at idx s in struct_set x y
-
-    | 0x06l -> array_new (at idx s)
-    | 0x07l -> array_new_default (at idx s)
+    | 0x00l -> let x = at idx s in struct_new x
+    | 0x01l -> let x = at idx s in struct_new_default x
+    | 0x02l -> let x = at idx s in let i = idx s in struct_get x i
+    | 0x03l -> let x = at idx s in let i = idx s in struct_get_s x i
+    | 0x04l -> let x = at idx s in let i = idx s in struct_get_u x i
+    | 0x05l -> let x = at idx s in let i = idx s in struct_set x i
+
+    | 0x06l -> let x = at idx s in array_new x
+    | 0x07l -> let x = at idx s in array_new_default x
     | 0x08l -> let x = at idx s in let n = u32 s in array_new_fixed x n
     | 0x09l -> let x = at idx s in let y = at idx s in array_new_data x y
     | 0x0al -> let x = at idx s in let y = at idx s in array_new_elem x y
-    | 0x0bl -> array_get (at idx s)
-    | 0x0cl -> array_get_s (at idx s)
-    | 0x0dl -> array_get_u (at idx s)
-    | 0x0el -> array_set (at idx s)
+    | 0x0bl -> let x = at idx s in array_get x
+    | 0x0cl -> let x = at idx s in array_get_s x
+    | 0x0dl -> let x = at idx s in array_get_u x
+    | 0x0el -> let x = at idx s in array_set x
     | 0x0fl -> array_len
-    | 0x10l -> array_fill (at idx s)
+    | 0x10l -> let x = at idx s in array_fill x
     | 0x11l -> let x = at idx s in let y = at idx s in array_copy x y
     | 0x12l -> let x = at idx s in let y = at idx s in array_init_data x y
     | 0x13l -> let x = at idx s in let y = at idx s in array_init_elem x y
 
-    | 0x14l -> ref_test (NoNull, heaptype s)
-    | 0x15l -> ref_test (Null, heaptype s)
-    | 0x16l -> ref_cast (NoNull, heaptype s)
-    | 0x17l -> ref_cast (Null, heaptype s)
+    | 0x14l -> let ht = heaptype s in ref_test (NoNull, ht)
+    | 0x15l -> let ht = heaptype s in ref_test (Null, ht)
+    | 0x16l -> let ht = heaptype s in ref_cast (NoNull, ht)
+    | 0x17l -> let ht = heaptype s in ref_cast (Null, ht)
     | 0x18l | 0x19l as opcode ->
       let flags = byte s in
       require (flags land 0xfc = 0) s (pos + 2) "malformed br_on_cast flags";
@@ -676,29 +670,17 @@ let rec instr s =
     | 0x06l -> i64_trunc_sat_f64_s
     | 0x07l -> i64_trunc_sat_f64_u
 
-    | 0x08l ->
-      let y = at idx s in
-      let x = at idx s in
-      memory_init x y
-    | 0x09l -> data_drop (at idx s)
-    | 0x0al ->
-      let x = at idx s in
-      let y = at idx s in
-      memory_copy x y
-    | 0x0bl -> memory_fill (at idx s)
+    | 0x08l -> let y = at idx s in let x = at idx s in memory_init x y
+    | 0x09l -> let x = at idx s in data_drop x
+    | 0x0al -> let x = at idx s in let y = at idx s in memory_copy x y
+    | 0x0bl -> let x = at idx s in memory_fill x
 
-    | 0x0cl ->
-      let y = at idx s in
-      let x = at idx s in
-      table_init x y
-    | 0x0dl -> elem_drop (at idx s)
-    | 0x0el ->
-      let x = at idx s in
-      let y = at idx s in
-      table_copy x y
-    | 0x0fl -> table_grow (at idx s)
-    | 0x10l -> table_size (at idx s)
-    | 0x11l -> table_fill (at idx s)
+    | 0x0cl -> let y = at idx s in let x = at idx s in table_init x y
+    | 0x0dl -> let x = at idx s in elem_drop x
+    | 0x0el -> let x = at idx s in let y = at idx s in table_copy x y
+    | 0x0fl -> let x = at idx s in table_grow x
+    | 0x10l -> let x = at idx s in table_size x
+    | 0x11l -> let x = at idx s in table_fill x
 
     | n -> illegal2 s pos b n
     )
@@ -717,8 +699,8 @@ let rec instr s =
     | 0x09l -> let x, a, o = memop s in v128_load32_splat x a o
     | 0x0al -> let x, a, o = memop s in v128_load64_splat x a o
     | 0x0bl -> let x, a, o = memop s in v128_store x a o
-    | 0x0cl -> v128_const (at v128 s)
-    | 0x0dl -> i8x16_shuffle (List.init 16 (fun _ -> byte s))
+    | 0x0cl -> let c = at v128 s in v128_const c
+    | 0x0dl -> let is = repeat 16 laneidx s in i8x16_shuffle is
     | 0x0el -> i8x16_swizzle
     | 0x0fl -> i8x16_splat
     | 0x10l -> i16x8_splat
@@ -726,20 +708,20 @@ let rec instr s =
     | 0x12l -> i64x2_splat
     | 0x13l -> f32x4_splat
     | 0x14l -> f64x2_splat
-    | 0x15l -> let i = byte s in i8x16_extract_lane_s i
-    | 0x16l -> let i = byte s in i8x16_extract_lane_u i
-    | 0x17l -> let i = byte s in i8x16_replace_lane i
-    | 0x18l -> let i = byte s in i16x8_extract_lane_s i
-    | 0x19l -> let i = byte s in i16x8_extract_lane_u i
-    | 0x1al -> let i = byte s in i16x8_replace_lane i
-    | 0x1bl -> let i = byte s in i32x4_extract_lane i
-    | 0x1cl -> let i = byte s in i32x4_replace_lane i
-    | 0x1dl -> let i = byte s in i64x2_extract_lane i
-    | 0x1el -> let i = byte s in i64x2_replace_lane i
-    | 0x1fl -> let i = byte s in f32x4_extract_lane i
-    | 0x20l -> let i = byte s in f32x4_replace_lane i
-    | 0x21l -> let i = byte s in f64x2_extract_lane i
-    | 0x22l -> let i = byte s in f64x2_replace_lane i
+    | 0x15l -> let i = laneidx s in i8x16_extract_lane_s i
+    | 0x16l -> let i = laneidx s in i8x16_extract_lane_u i
+    | 0x17l -> let i = laneidx s in i8x16_replace_lane i
+    | 0x18l -> let i = laneidx s in i16x8_extract_lane_s i
+    | 0x19l -> let i = laneidx s in i16x8_extract_lane_u i
+    | 0x1al -> let i = laneidx s in i16x8_replace_lane i
+    | 0x1bl -> let i = laneidx s in i32x4_extract_lane i
+    | 0x1cl -> let i = laneidx s in i32x4_replace_lane i
+    | 0x1dl -> let i = laneidx s in i64x2_extract_lane i
+    | 0x1el -> let i = laneidx s in i64x2_replace_lane i
+    | 0x1fl -> let i = laneidx s in f32x4_extract_lane i
+    | 0x20l -> let i = laneidx s in f32x4_replace_lane i
+    | 0x21l -> let i = laneidx s in f64x2_extract_lane i
+    | 0x22l -> let i = laneidx s in f64x2_replace_lane i
     | 0x23l -> i8x16_eq
     | 0x24l -> i8x16_ne
     | 0x25l -> i8x16_lt_s
@@ -790,37 +772,21 @@ let rec instr s =
     | 0x52l -> v128_bitselect
     | 0x53l -> v128_any_true
     | 0x54l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_load8_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_load8_lane x a o i
     | 0x55l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_load16_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_load16_lane x a o i
     | 0x56l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_load32_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_load32_lane x a o i
     | 0x57l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_load64_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_load64_lane x a o i
     | 0x58l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_store8_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_store8_lane x a o i
     | 0x59l ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_store16_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_store16_lane x a o i
     | 0x5al ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_store32_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_store32_lane x a o i
     | 0x5bl ->
-      let x, a, o = memop s in
-      let lane = byte s in
-      v128_store64_lane x a o lane
+      let x, a, o = memop s in let i = laneidx s in v128_store64_lane x a o i
     | 0x5cl -> let x, a, o = memop s in v128_load32_zero x a o
     | 0x5dl -> let x, a, o = memop s in v128_load64_zero x a o
     | 0x5el -> f32x4_demote_f64x2_zero
@@ -1011,16 +977,10 @@ and instr_block' s es =
 
 and catch s =
   match byte s with
-  | 0x00 ->
-    let x1 = at idx s in
-    let x2 = at idx s in
-    Mnemonics.catch x1 x2
-  | 0x01 ->
-    let x1 = at idx s in
-    let x2 = at idx s in
-    catch_ref x1 x2
-  | 0x02 -> catch_all (at idx s)
-  | 0x03 -> catch_all_ref (at idx s)
+  | 0x00 -> let x = at idx s in let y = at idx s in Mnemonics.catch x y
+  | 0x01 -> let x = at idx s in let y = at idx s in catch_ref x y
+  | 0x02 -> let x = at idx s in catch_all x
+  | 0x03 -> let x = at idx s in catch_all_ref x
   | _ -> error s (pos s - 1) "malformed catch clause"
 
 let const s =
@@ -1145,11 +1105,11 @@ let global_section s =
 
 let externidx s =
   match byte s with
-  | 0x00 -> FuncX (at idx s)
-  | 0x01 -> TableX (at idx s)
-  | 0x02 -> MemoryX (at idx s)
-  | 0x03 -> GlobalX (at idx s)
-  | 0x04 -> TagX (at idx s)
+  | 0x00 -> let x = at idx s in FuncX x
+  | 0x01 -> let x = at idx s in TableX x
+  | 0x02 -> let x = at idx s in MemoryX x
+  | 0x03 -> let x = at idx s in GlobalX x
+  | 0x04 -> let x = at idx s in TagX x
   | _ -> error s (pos s - 1) "malformed export kind"
 
 let export s =
@@ -1185,21 +1145,10 @@ let code_section s =
 
 (* Element section *)
 
-let passive s =
-  Passive
-
-let active s =
-  let x = at idx s in
-  let c = const s in
-  Active (x, c)
-
-let active_zero s =
-  let x = 0l @@ no_region in
-  let c = const s in
-  Active (x, c)
-
-let declarative s =
-  Declarative
+let passive s = Passive
+let active s = let x = at idx s in let c = const s in Active (x, c)
+let active_zero s = let x = 0l @@ no_region in let c = const s in Active (x, c)
+let declarative s = Declarative
 
 let elem_index s =
   let x = at idx s in
diff --git a/interpreter/binary/encode.ml b/interpreter/binary/encode.ml
index 4a470b1b9..a324ea22f 100644
--- a/interpreter/binary/encode.ml
+++ b/interpreter/binary/encode.ml
@@ -61,6 +61,7 @@ struct
     if -64L <= i && i < 64L then byte b
     else (byte (b lor 0x80); s64 (Int64.shift_right i 7))
 
+  let u8 i = u64 Int64.(logand (of_int (I8.to_int_u i)) 0xffL)
   let u32 i = u64 Int64.(logand (of_int32 i) 0xffffffffL)
   let s7 i = s64 (Int64.of_int i)
   let s32 i = s64 (Int64.of_int32 i)
@@ -394,25 +395,25 @@ struct
       error e.at "illegal instruction v128.loadNxM_x"
 
     | VecLoadLane (x, ({ty = V128T; pack = Pack8; _} as mo), i) ->
-      vecop 0x54l; memop x mo; byte i;
+      vecop 0x54l; memop x mo; u8 i;
     | VecLoadLane (x, ({ty = V128T; pack = Pack16; _} as mo), i) ->
-      vecop 0x55l; memop x mo; byte i;
+      vecop 0x55l; memop x mo; u8 i;
     | VecLoadLane (x, ({ty = V128T; pack = Pack32; _} as mo), i) ->
-      vecop 0x56l; memop x mo; byte i;
+      vecop 0x56l; memop x mo; u8 i;
     | VecLoadLane (x, ({ty = V128T; pack = Pack64; _} as mo), i) ->
-      vecop 0x57l; memop x mo; byte i;
+      vecop 0x57l; memop x mo; u8 i;
 
     | VecStore (x, ({ty = V128T; _} as mo)) ->
       vecop 0x0bl; memop x mo
 
     | VecStoreLane (x, ({ty = V128T; pack = Pack8; _} as mo), i) ->
-      vecop 0x58l; memop x mo; byte i;
+      vecop 0x58l; memop x mo; u8 i;
     | VecStoreLane (x, ({ty = V128T; pack = Pack16; _} as mo), i) ->
-      vecop 0x59l; memop x mo; byte i;
+      vecop 0x59l; memop x mo; u8 i;
     | VecStoreLane (x, ({ty = V128T; pack = Pack32; _} as mo), i) ->
-      vecop 0x5al; memop x mo; byte i;
+      vecop 0x5al; memop x mo; u8 i;
     | VecStoreLane (x, ({ty = V128T; pack = Pack64; _} as mo), i) ->
-      vecop 0x5bl; memop x mo; byte i;
+      vecop 0x5bl; memop x mo; u8 i;
 
     | MemorySize x -> op 0x3f; idx x
     | MemoryGrow x -> op 0x40; idx x
@@ -439,10 +440,10 @@ struct
 
     | StructNew (x, Explicit) -> op 0xfb; op 0x00; idx x
     | StructNew (x, Implicit) -> op 0xfb; op 0x01; idx x
-    | StructGet (x, y, None) -> op 0xfb; op 0x02; idx x; idx y
-    | StructGet (x, y, Some S) -> op 0xfb; op 0x03; idx x; idx y
-    | StructGet (x, y, Some U) -> op 0xfb; op 0x04; idx x; idx y
-    | StructSet (x, y) -> op 0xfb; op 0x05; idx x; idx y
+    | StructGet (x, i, None) -> op 0xfb; op 0x02; idx x; u32 i
+    | StructGet (x, i, Some S) -> op 0xfb; op 0x03; idx x; u32 i
+    | StructGet (x, i, Some U) -> op 0xfb; op 0x04; idx x; u32 i
+    | StructSet (x, i) -> op 0xfb; op 0x05; idx x; u32 i
 
     | ArrayNew (x, Explicit) -> op 0xfb; op 0x06; idx x
     | ArrayNew (x, Implicit) -> op 0xfb; op 0x07; idx x
@@ -728,7 +729,8 @@ struct
     | VecCompare (V128 (F64x2 V128Op.Le)) -> vecop 0x4bl
     | VecCompare (V128 (F64x2 V128Op.Ge)) -> vecop 0x4cl
 
-    | VecBinary (V128 (I8x16 (V128Op.Shuffle is))) -> vecop 0x0dl; List.iter byte is
+    | VecBinary (V128 (I8x16 (V128Op.Shuffle is))) ->
+      vecop 0x0dl; List.iter u8 is
     | VecBinary (V128 (I8x16 V128Op.Swizzle)) -> vecop 0x0el
     | VecBinary (V128 (I8x16 V128Op.(Narrow S))) -> vecop 0x65l
     | VecBinary (V128 (I8x16 V128Op.(Narrow U))) -> vecop 0x66l
@@ -895,21 +897,21 @@ struct
     | VecSplat (V128 ((F32x4 V128Op.Splat))) -> vecop 0x13l
     | VecSplat (V128 ((F64x2 V128Op.Splat))) -> vecop 0x14l
 
-    | VecExtract (V128 (I8x16 V128Op.(Extract (i, S)))) -> vecop 0x15l; byte i
-    | VecExtract (V128 (I8x16 V128Op.(Extract (i, U)))) -> vecop 0x16l; byte i
-    | VecExtract (V128 (I16x8 V128Op.(Extract (i, S)))) -> vecop 0x18l; byte i
-    | VecExtract (V128 (I16x8 V128Op.(Extract (i, U)))) -> vecop 0x19l; byte i
-    | VecExtract (V128 (I32x4 V128Op.(Extract (i, ())))) -> vecop 0x1bl; byte i
-    | VecExtract (V128 (I64x2 V128Op.(Extract (i, ())))) -> vecop 0x1dl; byte i
-    | VecExtract (V128 (F32x4 V128Op.(Extract (i, ())))) -> vecop 0x1fl; byte i
-    | VecExtract (V128 (F64x2 V128Op.(Extract (i, ())))) -> vecop 0x21l; byte i
-
-    | VecReplace (V128 (I8x16 V128Op.(Replace i))) -> vecop 0x17l; byte i
-    | VecReplace (V128 (I16x8 V128Op.(Replace i))) -> vecop 0x1al; byte i
-    | VecReplace (V128 (I32x4 V128Op.(Replace i))) -> vecop 0x1cl; byte i
-    | VecReplace (V128 (I64x2 V128Op.(Replace i))) -> vecop 0x1el; byte i
-    | VecReplace (V128 (F32x4 V128Op.(Replace i))) -> vecop 0x20l; byte i
-    | VecReplace (V128 (F64x2 V128Op.(Replace i))) -> vecop 0x22l; byte i
+    | VecExtract (V128 (I8x16 V128Op.(Extract (i, S)))) -> vecop 0x15l; u8 i
+    | VecExtract (V128 (I8x16 V128Op.(Extract (i, U)))) -> vecop 0x16l; u8 i
+    | VecExtract (V128 (I16x8 V128Op.(Extract (i, S)))) -> vecop 0x18l; u8 i
+    | VecExtract (V128 (I16x8 V128Op.(Extract (i, U)))) -> vecop 0x19l; u8 i
+    | VecExtract (V128 (I32x4 V128Op.(Extract (i, ())))) -> vecop 0x1bl; u8 i
+    | VecExtract (V128 (I64x2 V128Op.(Extract (i, ())))) -> vecop 0x1dl; u8 i
+    | VecExtract (V128 (F32x4 V128Op.(Extract (i, ())))) -> vecop 0x1fl; u8 i
+    | VecExtract (V128 (F64x2 V128Op.(Extract (i, ())))) -> vecop 0x21l; u8 i
+
+    | VecReplace (V128 (I8x16 V128Op.(Replace i))) -> vecop 0x17l; u8 i
+    | VecReplace (V128 (I16x8 V128Op.(Replace i))) -> vecop 0x1al; u8 i
+    | VecReplace (V128 (I32x4 V128Op.(Replace i))) -> vecop 0x1cl; u8 i
+    | VecReplace (V128 (I64x2 V128Op.(Replace i))) -> vecop 0x1el; u8 i
+    | VecReplace (V128 (F32x4 V128Op.(Replace i))) -> vecop 0x20l; u8 i
+    | VecReplace (V128 (F64x2 V128Op.(Replace i))) -> vecop 0x22l; u8 i
 
   and catch c =
     match c.it with
diff --git a/interpreter/exec/eval.ml b/interpreter/exec/eval.ml
index 49d5f0275..555f85caa 100644
--- a/interpreter/exec/eval.ml
+++ b/interpreter/exec/eval.ml
@@ -499,17 +499,17 @@ let rec step (c : config) : config =
           let v =
             match pack with
             | Pack8 ->
-              V128.I8x16.replace_lane j v
-                (I32Num.of_num 0 (Memory.load_num_packed Pack8 S mem i_64 offset I32T))
+              let num = Memory.load_num_packed Pack8 S mem i_64 offset I32T in
+              V128.I8x16.replace_lane j v (I8.of_i32_u (I32Num.of_num 0 num))
             | Pack16 ->
-              V128.I16x8.replace_lane j v
-                (I32Num.of_num 0 (Memory.load_num_packed Pack16 S mem i_64 offset I32T))
+              let num = Memory.load_num_packed Pack16 S mem i_64 offset I32T in
+              V128.I16x8.replace_lane j v (I16.of_i32_u (I32Num.of_num 0 num))
             | Pack32 ->
-              V128.I32x4.replace_lane j v
-                (I32Num.of_num 0 (Memory.load_num mem i_64 offset I32T))
+              let num = Memory.load_num mem i_64 offset I32T in
+              V128.I32x4.replace_lane j v (I32Num.of_num 0 num)
             | Pack64 ->
-              V128.I64x2.replace_lane j v
-                (I64Num.of_num 0 (Memory.load_num mem i_64 offset I64T))
+              let num = Memory.load_num mem i_64 offset I64T in
+              V128.I64x2.replace_lane j v (I64Num.of_num 0 num)
           in Vec (V128 v) :: vs', []
         with exn -> vs', [Trapping (memory_error e.at exn) @@ e.at])
 
@@ -519,13 +519,17 @@ let rec step (c : config) : config =
         (try
           (match pack with
           | Pack8 ->
-            Memory.store_num_packed Pack8 mem i_64 offset (I32 (V128.I8x16.extract_lane_s j v))
+            let num = I32 (I8.to_i32_u (V128.I8x16.extract_lane_s j v)) in
+            Memory.store_num_packed Pack8 mem i_64 offset num
           | Pack16 ->
-            Memory.store_num_packed Pack16 mem i_64 offset (I32 (V128.I16x8.extract_lane_s j v))
+            let num = I32 (I16.to_i32_u (V128.I16x8.extract_lane_s j v)) in
+            Memory.store_num_packed Pack16 mem i_64 offset num
           | Pack32 ->
-            Memory.store_num mem i_64 offset (I32 (V128.I32x4.extract_lane_s j v))
+            let num = I32 (V128.I32x4.extract_lane_s j v) in
+            Memory.store_num mem i_64 offset num
           | Pack64 ->
-            Memory.store_num mem i_64 offset (I64 (V128.I64x2.extract_lane_s j v))
+            let num = I64 (V128.I64x2.extract_lane_s j v) in
+            Memory.store_num mem i_64 offset num
           );
           vs', []
         with exn -> vs', [Trapping (memory_error e.at exn) @@ e.at])
@@ -684,24 +688,24 @@ let rec step (c : config) : config =
           with Failure _ -> Crash.error e.at "type mismatch packing value"
         in Ref (Aggr.StructRef struct_) :: vs'', []
 
-      | StructGet (x, y, exto), Ref (NullRef _) :: vs' ->
+      | StructGet (x, i, exto), Ref (NullRef _) :: vs' ->
         vs', [Trapping "null structure reference" @@ e.at]
 
-      | StructGet (x, y, exto), Ref Aggr.(StructRef (Struct (_, fs))) :: vs' ->
+      | StructGet (x, i, exto), Ref Aggr.(StructRef (Struct (_, fs))) :: vs' ->
         let f =
-          try Lib.List32.nth fs y.it
-          with Failure _ -> Crash.error y.at "undefined field"
+          try Lib.List32.nth fs i
+          with Failure _ -> Crash.error e.at "undefined field"
         in
         (try Aggr.read_field f exto :: vs', []
         with Failure _ -> Crash.error e.at "type mismatch reading field")
 
-      | StructSet (x, y), v :: Ref (NullRef _) :: vs' ->
+      | StructSet (x, i), v :: Ref (NullRef _) :: vs' ->
         vs', [Trapping "null structure reference" @@ e.at]
 
-      | StructSet (x, y), v :: Ref Aggr.(StructRef (Struct (_, fs))) :: vs' ->
+      | StructSet (x, i), v :: Ref Aggr.(StructRef (Struct (_, fs))) :: vs' ->
         let f =
-          try Lib.List32.nth fs y.it
-          with Failure _ -> Crash.error y.at "undefined field"
+          try Lib.List32.nth fs i
+          with Failure _ -> Crash.error e.at "undefined field"
         in
         (try Aggr.write_field f v; vs', []
         with Failure _ -> Crash.error e.at "type mismatch writing field")
diff --git a/interpreter/exec/eval_vec.ml b/interpreter/exec/eval_vec.ml
index 1bbef4a76..b0118da31 100644
--- a/interpreter/exec/eval_vec.ml
+++ b/interpreter/exec/eval_vec.ml
@@ -260,7 +260,7 @@ struct
 
   let vunop (op : vunop) =
     let f = match op with
-      | Not -> V128.V1x128.lognot
+      | Not -> V128.V1x128.not_
     in fun v -> to_vec (f (of_vec 1 v))
 
   let vbinop (op : vbinop) =
@@ -286,8 +286,8 @@ struct
   let splatop (op : splatop) v =
     let i =
       match op with
-      | I8x16 Splat -> V128.I8x16.splat (I32Num.of_num 1 v)
-      | I16x8 Splat -> V128.I16x8.splat (I32Num.of_num 1 v)
+      | I8x16 Splat -> V128.I8x16.splat (I8.of_i32_s (I32Num.of_num 1 v))
+      | I16x8 Splat -> V128.I16x8.splat (I16.of_i32_s (I32Num.of_num 1 v))
       | I32x4 Splat -> V128.I32x4.splat (I32Num.of_num 1 v)
       | I64x2 Splat -> V128.I64x2.splat (I64Num.of_num 1 v)
       | F32x4 Splat -> V128.F32x4.splat (F32Num.of_num 1 v)
@@ -297,10 +297,10 @@ struct
   let extractop (op : extractop) v =
     let v128 = of_vec 1 v in
     match op with
-    | I8x16 (Extract (i, S)) -> I32 (V128.I8x16.extract_lane_s i v128)
-    | I8x16 (Extract (i, U)) -> I32 (V128.I8x16.extract_lane_u i v128)
-    | I16x8 (Extract (i, S)) -> I32 (V128.I16x8.extract_lane_s i v128)
-    | I16x8 (Extract (i, U)) -> I32 (V128.I16x8.extract_lane_u i v128)
+    | I8x16 (Extract (i, S)) -> I32 (I8.to_i32_s (V128.I8x16.extract_lane_s i v128))
+    | I8x16 (Extract (i, U)) -> I32 (I8.to_i32_u (V128.I8x16.extract_lane_u i v128))
+    | I16x8 (Extract (i, S)) -> I32 (I16.to_i32_s (V128.I16x8.extract_lane_s i v128))
+    | I16x8 (Extract (i, U)) -> I32 (I16.to_i32_u (V128.I16x8.extract_lane_u i v128))
     | I32x4 (Extract (i, ())) -> I32 (V128.I32x4.extract_lane_u i v128)
     | I64x2 (Extract (i, ())) -> I64 (V128.I64x2.extract_lane_u i v128)
     | F32x4 (Extract (i, ())) -> F32 (V128.F32x4.extract_lane i v128)
@@ -309,8 +309,8 @@ struct
   let replaceop (op : replaceop) v (n : num) =
     let v128 = of_vec 1 v in
     let v128' = match op with
-      | I8x16 (Replace i) -> V128.I8x16.replace_lane i v128 (I32Num.of_num 1 n)
-      | I16x8 (Replace i) -> V128.I16x8.replace_lane i v128 (I32Num.of_num 1 n)
+      | I8x16 (Replace i) -> V128.I8x16.replace_lane i v128 (I8.of_i32_s (I32Num.of_num 1 n))
+      | I16x8 (Replace i) -> V128.I16x8.replace_lane i v128 (I16.of_i32_s (I32Num.of_num 1 n))
       | I32x4 (Replace i) -> V128.I32x4.replace_lane i v128 (I32Num.of_num 1 n)
       | I64x2 (Replace i) -> V128.I64x2.replace_lane i v128 (I64Num.of_num 1 n)
       | F32x4 (Replace i) -> V128.F32x4.replace_lane i v128 (F32Num.of_num 1 n)
diff --git a/interpreter/exec/i16.ml b/interpreter/exec/i16.ml
index 54eb9ed84..ce8c46687 100644
--- a/interpreter/exec/i16.ml
+++ b/interpreter/exec/i16.ml
@@ -2,11 +2,13 @@
  * stored signed-extended. E.g. -1 will be stored with all high bits set.
  *)
 include Ixx.Make (struct
-  include Int32
+  include Int
 
   let bitwidth = 16
-  let to_hex_string i = Printf.sprintf "%lx" (Int32.logand i 0xffffl)
+  let to_hex_string = Printf.sprintf "%x"
 
-  let of_int64 = Int64.to_int32
-  let to_int64 = Int64.of_int32
+  let of_int = Fun.id
+  let to_int = Fun.id
+  let of_int64 = Int64.to_int
+  let to_int64 = Int64.of_int
 end)
diff --git a/interpreter/exec/i8.ml b/interpreter/exec/i8.ml
index bd15d39da..5b2249305 100644
--- a/interpreter/exec/i8.ml
+++ b/interpreter/exec/i8.ml
@@ -2,11 +2,13 @@
  * stored signed-extended. E.g. -1 will be stored with all high bits set.
  *)
 include Ixx.Make (struct
-  include Int32
+  include Int
 
   let bitwidth = 8
-  let to_hex_string i = Printf.sprintf "%lx" (Int32.logand i 0xffl)
+  let to_hex_string = Printf.sprintf "%x"
 
-  let of_int64 = Int64.to_int32
-  let to_int64 = Int64.of_int32
+  let of_int = Fun.id
+  let to_int = Fun.id
+  let of_int64 = Int64.to_int
+  let to_int64 = Int64.of_int
 end)
diff --git a/interpreter/exec/ixx.ml b/interpreter/exec/ixx.ml
index 125fd40d5..8a6db743c 100644
--- a/interpreter/exec/ixx.ml
+++ b/interpreter/exec/ixx.ml
@@ -49,7 +49,7 @@ sig
 
   val zero : t
 
-  val lognot : t -> t
+  val not_ : t -> t
   val abs : t -> t
   val neg : t -> t
   val add : t -> t -> t
@@ -97,11 +97,15 @@ sig
 
   val of_int_s : int -> t
   val of_int_u : int -> t
+  val of_i32_s : int32 -> t
+  val of_i32_u : int32 -> t
   val of_string_s : string -> t
   val of_string_u : string -> t
   val of_string : string -> t
   val to_int_s : t -> int
   val to_int_u : t -> int
+  val to_i32_s : t -> int32
+  val to_i32_u : t -> int32
   val to_string_s : t -> string
   val to_string_u : t -> string
   val to_hex_string : t -> string
@@ -109,6 +113,26 @@ end
 
 module Make (Rep : RepType) : T with type bits = Rep.t and type t = Rep.t =
 struct
+  type t = Rep.t
+  type bits = Rep.t
+
+  let bitwidth = Rep.bitwidth
+
+  let of_bits x = x
+  let to_bits x = x
+
+  let zero = Rep.zero
+  let one = Rep.one
+  let ten = Rep.of_int 10
+
+  let not_ = Rep.lognot
+  let and_ = Rep.logand
+  let or_ = Rep.logor
+  let xor = Rep.logxor
+
+  let abs = Rep.abs
+  let neg = Rep.neg
+
   (*
    * Unsigned comparison in terms of signed comparison.
    *)
@@ -131,32 +155,21 @@ struct
     else
       Rep.add q Rep.one, Rep.sub r d
 
-  type t = Rep.t
-  type bits = Rep.t
-
-  let bitwidth = Rep.bitwidth
-
-  let of_bits x = x
-  let to_bits x = x
-
-  let zero = Rep.zero
-  let one = Rep.one
-  let ten = Rep.of_int 10
-
-  let lognot = Rep.lognot
-  let abs = Rep.abs
-  let neg = Rep.neg
-
   (* If bit (bitwidth - 1) is set, sx will sign-extend t to maintain the
-   * invariant that small ints are stored sign-extended inside a wider int. *)
+   * invariant that small ints are stored sign-extended inside a wider int.
+   * In contrast, zx zero-extends the representation. *)
   let sx x =
     let i = 64 - Rep.bitwidth in
     Rep.of_int64 Int64.(shift_right (shift_left (Rep.to_int64 x) i) i)
 
+  let zx x =
+    let i = 64 - Rep.bitwidth in
+    let mask = Int64.shift_right_logical (-1L) i in
+    Rep.of_int64 Int64.(logand (Rep.to_int64 x) mask)
+
   (* add, sub, and mul are sign-agnostic and do not trap on overflow. *)
   let add x y = sx (Rep.add x y)
   let sub x y = sx (Rep.sub x y)
-
   let mul x y = sx (Rep.mul x y)
 
   (* We don't override min_int and max_int since those are used
@@ -198,19 +211,12 @@ struct
     let y64 = logand mask (Rep.to_int64 y) in
     Rep.of_int64 (div (add (add x64 y64) one) (of_int 2))
 
-  let and_ = Rep.logand
-  let or_ = Rep.logor
-  let xor = Rep.logxor
-
   (* WebAssembly's shifts mask the shift count according to the bitwidth. *)
-  let shift f x y =
-    f x Rep.(to_int (logand y (of_int (bitwidth - 1))))
-
-  let shl x y =
-    sx (shift Rep.shift_left x y)
+  let shift y = Rep.(to_int (logand y (of_int (bitwidth - 1))))
 
-  let shr_s x y =
-    shift Rep.shift_right x y
+  let shl x y = sx (Rep.shift_left x (shift y))
+  let shr_s x y = Rep.shift_right x (shift y)
+  let shr_u x y = Rep.shift_right_logical (zx x) (shift y)
 
   (* Check if we are storing smaller ints. *)
   let needs_extend = shl one (Rep.of_int (Rep.bitwidth - 1)) <> Rep.min_int
@@ -226,8 +232,15 @@ struct
     let mask = Rep.(shift_right_logical minus_one (32 - bitwidth)) in
     Rep.logand x mask
 
-  let shr_u x y =
-    sx (shift Rep.shift_right_logical (as_unsigned x) y)
+let as_unsigned x =
+if as_unsigned x <> zx x then
+Printf.printf "[%d] as_unsigned %s = %s <> %s = zx %s\n%!"
+bitwidth
+(Rep.to_hex_string x)
+(Rep.to_hex_string (as_unsigned x))
+(Rep.to_hex_string (zx x))
+(Rep.to_hex_string x);
+as_unsigned x
 
   (* We must mask the count to implement rotates via shifts. *)
   let clamp_rotate_count n =
@@ -314,11 +327,69 @@ struct
     let y64 = Rep.to_int64 y in
     saturate_s (Rep.of_int64 Int64.((shift_right (add (mul x64 y64) 0x4000L) 15)))
 
-  let to_int_s = Rep.to_int
+  (* Integer conversion *)
+
+(*
+module I =
+struct
+  let sx x =
+    let i = 64 - 8 in
+    Int64.to_int Int64.(shift_right (shift_left (Int64.of_int x) i) i)
+  let shift f x y = f x Int.(logand y (8 - 1))
+  let shl x y = sx (shift Int.shift_left x y)
+
+  let one = 1
+  let and_ = Int.logand
+  let or_ = Int.logor
+
+  let to_int_s = Fun.id
+  let to_int_u i = i land ((Int.max_int lsl 1) lor 1)
+
+  let of_int_s = Fun.id
+  let of_int_u i = and_ i (or_ (shl max_int one) one)
+
+  let to_i32_s i = Int32.of_int (to_int_s i)
+  let to_i32_u i = Int32.of_int (to_int_u i)
+
+  let of_i32_s i = of_int_s (Int32.to_int i)
+  let of_i32_u i = of_int_u (Int32.to_int i)
+end
+module Iw =
+struct
+  let sx x =
+    let i = 64 - 8 in
+    Int64.to_int32 Int64.(shift_right (shift_left (Int64.of_int32 x) i) i)
+  let shift f x y = f x Int32.(to_int (logand y (of_int (8 - 1))))
+  let shl x y = sx (shift Int32.shift_left x y)
+
+  let one = 1l
+  let and_ = Int32.logand
+  let or_ = Int32.logor
+
+  let to_int_s = Int32.to_int
+  let to_int_u i = Int32.to_int i land ((Int32.to_int Int32.max_int lsl 1) lor 1)
+
+  let of_int_s = Int32.of_int
+  let of_int_u i = and_ (Int32.of_int i) (or_ (shl (Int32.of_int max_int) one) one)
+
+  let to_i32_s i = Int32.of_int (to_int_s i)
+  let to_i32_u i = Int32.of_int (to_int_u i)
+
+  let of_i32_s i = of_int_s (Int32.to_int i)
+  let of_i32_u i = of_int_u (Int32.to_int i)
+end
+*)
+  let to_int_s i = Rep.to_int i
   let to_int_u i = Rep.to_int i land ((Rep.to_int Rep.max_int lsl 1) lor 1)
 
-  let of_int_s = Rep.of_int
-  let of_int_u i = and_ (Rep.of_int i) (or_ (shl (Rep.of_int max_int) one) one)
+  let of_int_s i = sx (Rep.of_int i)
+  let of_int_u i = zx (Rep.of_int i)
+
+  let to_i32_s i = Int32.of_int (to_int_s i)
+  let to_i32_u i = Int32.of_int (to_int_u i)
+
+  let of_i32_s i = of_int_s (Int32.to_int i)
+  let of_i32_u i = of_int_u (Int32.to_int i)
 
   (* String conversion that allows leading signs and unsigned values *)
 
@@ -424,5 +495,5 @@ struct
     else
       group_digits 3 (Rep.to_string (div_u i ten) ^ Rep.to_string (rem_u i ten))
 
-  let to_hex_string i = "0x" ^ group_digits 4 (Rep.to_hex_string i)
+  let to_hex_string i = "0x" ^ group_digits 4 (Rep.to_hex_string (zx i))
 end
diff --git a/interpreter/exec/v128.ml b/interpreter/exec/v128.ml
index caee9bd53..cb24c1704 100644
--- a/interpreter/exec/v128.ml
+++ b/interpreter/exec/v128.ml
@@ -248,11 +248,11 @@ module I8x16 = MakeIntShape (I8)
   (struct
     let shape = I8x16 ()
     let to_lanes s =
-      List.init 16 (fun i -> Int32.of_int (Bytes.get_int8 (Bytes.of_string s) i))
+      List.init 16 (fun i -> I8.of_int_s (Bytes.get_int8 (Bytes.of_string s) i))
     let of_lanes fs =
       assert (List.length fs = 16);
       let b = Bytes.create bytewidth in
-      List.iteri (fun i f -> Bytes.set_int8 b i (Int32.to_int f)) fs;
+      List.iteri (fun i f -> Bytes.set_int8 b i (I8.to_int_s f)) fs;
       Bytes.to_string b
   end)
 
@@ -260,11 +260,11 @@ module I16x8 = MakeIntShape (I16)
   (struct
     let shape = I16x8 ()
     let to_lanes s =
-      List.init 8 (fun i -> Int32.of_int (Bytes.get_int16_le (Bytes.of_string s) (i*2)))
+      List.init 8 (fun i -> I16.of_int_s (Bytes.get_int16_le (Bytes.of_string s) (i*2)))
     let of_lanes fs =
       assert (List.length fs = 8);
       let b = Bytes.create bytewidth in
-      List.iteri (fun i f -> Bytes.set_int16_le b (i*2) (Int32.to_int f)) fs;
+      List.iteri (fun i f -> Bytes.set_int16_le b (i*2) (I16.to_int_s f)) fs;
       Bytes.to_string b
   end)
 
@@ -325,11 +325,11 @@ struct
   let binop f x y =
     I64x2.of_lanes (List.map2 f (I64x2.to_lanes x) (I64x2.to_lanes y))
 
-  let lognot = unop I64.lognot
+  let not_ = unop I64.not_
   let and_ = binop I64.and_
   let or_ = binop I64.or_
   let xor = binop I64.xor
-  let andnot = binop (fun x y -> I64.and_ x (I64.lognot y))
+  let andnot = binop (fun x y -> I64.and_ x (I64.not_ y))
 
   let bitselect v1 v2 c =
     let v2_andnot_c = andnot v2 c in
@@ -343,7 +343,7 @@ struct
     let ns = I8x16.to_lanes v1 in
     let is = I8x16.to_lanes v2 in
     let select i =
-      Option.value (List.nth_opt ns (I32.to_int_u i)) ~default: I32.zero
+      Option.value (List.nth_opt ns (I8.to_int_u i)) ~default: I8.zero
     in I8x16.of_lanes (List.map select is)
 
   let shuffle v1 v2 is =
@@ -354,23 +354,27 @@ end
 
 (* Conversions *)
 
-let narrow to_lanes of_lanes sat_op x y =
-  let xy = to_lanes x @ to_lanes y in
+let narrow to_lanes to_int of_lanes sat_op x y =
+  let xy = List.map to_int (to_lanes x @ to_lanes y) in
   of_lanes (List.map sat_op xy)
 
 module I8x16_convert =
 struct
-  let narrow_s = narrow I16x8.to_lanes I8x16.of_lanes I8.saturate_s
-  let narrow_u = narrow I16x8.to_lanes I8x16.of_lanes I8.saturate_u
+  let narrow_s = narrow I16x8.to_lanes I16.to_int_s I8x16.of_lanes I8.saturate_s
+  let narrow_u = narrow I16x8.to_lanes I16.to_int_s I8x16.of_lanes I8.saturate_u
+
+let narrow_u x y =
+let z = narrow_u x y in
+z
 end
 
 module I16x8_convert =
 struct
-  let narrow_s = narrow I32x4.to_lanes I16x8.of_lanes I16.saturate_s
-  let narrow_u = narrow I32x4.to_lanes I16x8.of_lanes I16.saturate_u
+  let narrow_s = narrow I32x4.to_lanes I32.to_int_s I16x8.of_lanes I16.saturate_s
+  let narrow_u = narrow I32x4.to_lanes I32.to_int_u I16x8.of_lanes I16.saturate_u
 
-  let ext_s = Int32.logand 0xffffffffl
-  let ext_u = Int32.logand 0xffl
+  let ext_s i = I16.of_int_s (I8.to_int_s i)
+  let ext_u i = I16.of_int_u (I8.to_int_u i)
 
   let extend take_or_drop ext x =
     I16x8.of_lanes (List.map ext (take_or_drop 8 (I8x16.to_lanes x)))
@@ -384,19 +388,19 @@ struct
   let extmul_low_u x y = I16x8.mul (extend_low_u x) (extend_low_u y)
   let extmul_high_u x y = I16x8.mul (extend_high_u x) (extend_high_u y)
 
-  let extadd ext x y = Int32.add (ext x) (ext y)
+  let extadd ext x y = I16.add (ext x) (ext y)
   let extadd_pairwise_s x =
     I16x8.of_lanes (Lib.List.map_pairwise (extadd ext_s) (I8x16.to_lanes x))
   let extadd_pairwise_u x =
     I16x8.of_lanes (Lib.List.map_pairwise (extadd ext_u) (I8x16.to_lanes x))
 
   let dot_s x y =
-    let xs = I8x16.to_lanes x in
-    let ys = I8x16.to_lanes y in
+    let xs = List.map ext_s (I8x16.to_lanes x) in
+    let ys = List.map ext_s (I8x16.to_lanes y) in
     let rec dot xs ys =
       match xs, ys with
       | x1::x2::xs', y1::y2::ys' ->
-        Int32.(add (mul x1 y1) (mul x2 y2)) :: dot xs' ys'
+        I16.(add (mul x1 y1) (mul x2 y2)) :: dot xs' ys'
       | [], [] -> []
       | _, _ -> assert false
     in I16x8.of_lanes (dot xs ys)
@@ -413,8 +417,8 @@ struct
   let trunc_sat_f64x2_s_zero = convert_zero Convert.I32_.trunc_sat_f64_s
   let trunc_sat_f64x2_u_zero = convert_zero Convert.I32_.trunc_sat_f64_u
 
-  let ext_s = Int32.logand 0xffffffffl
-  let ext_u = Int32.logand 0xffffl
+  let ext_s i = I32.of_int_s (I16.to_int_s i)
+  let ext_u i = I32.of_int_u (I16.to_int_u i)
 
   let extend take_or_drop ext x =
     I32x4.of_lanes (List.map ext (take_or_drop 4 (I16x8.to_lanes x)))
@@ -424,8 +428,8 @@ struct
   let extend_high_u = extend Lib.List.drop ext_u
 
   let dot_s x y =
-    let xs = I16x8.to_lanes x in
-    let ys = I16x8.to_lanes y in
+    let xs = List.map ext_s (I16x8.to_lanes x) in
+    let ys = List.map ext_s (I16x8.to_lanes y) in
     let rec dot xs ys =
       match xs, ys with
       | x1::x2::xss, y1::y2::yss ->
@@ -435,8 +439,8 @@ struct
     in I32x4.of_lanes (dot xs ys)
 
   let dot_add_s x y z =
-    let xs = I8x16.to_lanes x in
-    let ys = I8x16.to_lanes y in
+    let xs = List.map ext_s (I8x16.to_lanes x) in
+    let ys = List.map ext_s (I8x16.to_lanes y) in
     let rec dot xs ys =
       match xs, ys with
       | x1::x2::x3::x4::xs', y1::y2::y3::y4::ys' ->
diff --git a/interpreter/exec/v128.mli b/interpreter/exec/v128.mli
index 89262dc4d..a763d1419 100644
--- a/interpreter/exec/v128.mli
+++ b/interpreter/exec/v128.mli
@@ -128,7 +128,7 @@ module F64x2 : FloatShape with type lane = F64.t
 
 module V1x128 :
 sig
-  val lognot : t -> t
+  val not_ : t -> t
   val and_ : t -> t -> t
   val or_ : t -> t -> t
   val xor : t -> t -> t
diff --git a/interpreter/script/js.ml b/interpreter/script/js.ml
index fa6690945..21b393cfc 100644
--- a/interpreter/script/js.ml
+++ b/interpreter/script/js.ml
@@ -517,9 +517,11 @@ let assert_return ress ts at =
         V128.I32x4.of_lanes (List.init 4 (fun _ -> Int32.minus_one)) in
       let mask, expected = match shape with
         | V128.I8x16 () ->
-          all_ones, V128.I8x16.of_lanes (List.map (I32Num.of_num 0) canons)
+          all_ones, V128.I8x16.of_lanes
+            (List.map I8.of_i32_u (List.map (I32Num.of_num 0) canons))
         | V128.I16x8 () ->
-          all_ones, V128.I16x8.of_lanes (List.map (I32Num.of_num 0) canons)
+          all_ones, V128.I16x8.of_lanes
+            (List.map I16.of_i32_u (List.map (I32Num.of_num 0) canons))
         | V128.I32x4 () ->
           all_ones, V128.I32x4.of_lanes (List.map (I32Num.of_num 0) canons)
         | V128.I64x2 () ->
diff --git a/interpreter/script/run.ml b/interpreter/script/run.ml
index 2c4a31ced..528e4811a 100644
--- a/interpreter/script/run.ml
+++ b/interpreter/script/run.ml
@@ -393,8 +393,8 @@ let assert_vec_pat v p =
   match v, p with
   | V128 v, VecPat (V128 (shape, ps)) ->
     let extract = match shape with
-      | V128.I8x16 () -> fun v i -> I32 (V128.I8x16.extract_lane_s i v)
-      | V128.I16x8 () -> fun v i -> I32 (V128.I16x8.extract_lane_s i v)
+      | V128.I8x16 () -> fun v i -> I32 (I8.to_i32_u (V128.I8x16.extract_lane_s i v))
+      | V128.I16x8 () -> fun v i -> I32 (I16.to_i32_u (V128.I16x8.extract_lane_s i v))
       | V128.I32x4 () -> fun v i -> I32 (V128.I32x4.extract_lane_s i v)
       | V128.I64x2 () -> fun v i -> I64 (V128.I64x2.extract_lane_s i v)
       | V128.F32x4 () -> fun v i -> F32 (V128.F32x4.extract_lane i v)
diff --git a/interpreter/syntax/ast.ml b/interpreter/syntax/ast.ml
index 183241cba..bd5f145ea 100644
--- a/interpreter/syntax/ast.ml
+++ b/interpreter/syntax/ast.ml
@@ -61,6 +61,7 @@ module F64Op = FloatOp
 
 module V128Op =
 struct
+  type laneidx = I8.t
   type half = Low | High
 
   type iunop = Abs | Neg | Popcnt
@@ -68,7 +69,7 @@ struct
   type ibinop = Add | Sub | Mul | Min of sx | Max of sx | AvgrU
               | AddSat of sx | SubSat of sx | DotS | Q15MulRSatS
               | ExtMul of half * sx
-              | Swizzle | Shuffle of int list | Narrow of sx
+              | Swizzle | Shuffle of laneidx list | Narrow of sx
               | RelaxedSwizzle | RelaxedQ15MulRS | RelaxedDot
   type fbinop = Add | Sub | Mul | Div | Min | Max | Pmin | Pmax
               | RelaxedMin | RelaxedMax
@@ -100,8 +101,8 @@ struct
   type bitmaskop = (ibitmaskop, ibitmaskop, ibitmaskop, ibitmaskop, void, void) V128.laneop
 
   type nsplatop = Splat
-  type 'a nextractop = Extract of int * 'a
-  type nreplaceop = Replace of int
+  type 'a nextractop = Extract of laneidx * 'a
+  type nreplaceop = Replace of laneidx
 
   type splatop = (nsplatop, nsplatop, nsplatop, nsplatop, nsplatop, nsplatop) V128.laneop
   type extractop = (sx nextractop, sx nextractop, unit nextractop, unit nextractop, unit nextractop, unit nextractop) V128.laneop
@@ -144,117 +145,130 @@ type externop = Internalize | Externalize
 
 (* Expressions *)
 
-type idx = int32 Source.phrase
+type idx = I32.t Source.phrase
+type typeidx = idx
+type tagidx = idx
+type globalidx = idx
+type memoryidx = idx
+type tableidx = idx
+type funcidx = idx
+type dataidx = idx
+type elemidx = idx
+type localidx = idx
+type labelidx = idx
+type fieldidx = I32.t
+type laneidx = I8.t
+
 type num = Value.num Source.phrase
 type vec = Value.vec Source.phrase
 type name = Utf8.unicode
 
-type blocktype = VarBlockType of idx | ValBlockType of valtype option
+type blocktype = VarBlockType of typeidx | ValBlockType of valtype option
 
 type instr = instr' Source.phrase
 and instr' =
-  | Unreachable                       (* trap unconditionally *)
-  | Nop                               (* do nothing *)
-  | Drop                              (* forget a value *)
-  | Select of valtype list option     (* branchless conditional *)
-  | Block of blocktype * instr list   (* execute in sequence *)
-  | Loop of blocktype * instr list    (* loop header *)
+  | Unreachable                          (* trap unconditionally *)
+  | Nop                                  (* do nothing *)
+  | Drop                                 (* forget a value *)
+  | Select of valtype list option        (* branchless conditional *)
+  | Block of blocktype * instr list      (* execute in sequence *)
+  | Loop of blocktype * instr list       (* loop header *)
   | If of blocktype * instr list * instr list   (* conditional *)
-  | Br of idx                         (* break to n-th surrounding label *)
-  | BrIf of idx                       (* conditional break *)
-  | BrTable of idx list * idx         (* indexed break *)
-  | BrOnNull of idx                   (* break on type *)
-  | BrOnNonNull of idx                (* break on type inverted *)
-  | BrOnCast of idx * reftype * reftype     (* break on type *)
-  | BrOnCastFail of idx * reftype * reftype (* break on type inverted *)
-  | Return                            (* break from function body *)
-  | Call of idx                       (* call function *)
-  | CallRef of idx                    (* call function through reference *)
-  | CallIndirect of idx * idx         (* call function through table *)
-  | ReturnCall of idx                 (* tail-call function *)
-  | ReturnCallRef of idx              (* tail call through reference *)
-  | ReturnCallIndirect of idx * idx   (* tail-call function through table *)
-  | Throw of idx                      (* throw exception *)
-  | ThrowRef                          (* rethrow exception *)
+  | Br of labelidx                       (* break to n-th surrounding label *)
+  | BrIf of labelidx                     (* conditional break *)
+  | BrTable of labelidx list * labelidx  (* indexed break *)
+  | BrOnNull of labelidx                 (* break on type *)
+  | BrOnNonNull of labelidx              (* break on type inverted *)
+  | BrOnCast of labelidx * reftype * reftype     (* break on type *)
+  | BrOnCastFail of labelidx * reftype * reftype (* break on type inverted *)
+  | Return                               (* break from function body *)
+  | Call of funcidx                      (* call function *)
+  | CallRef of typeidx                   (* call function through reference *)
+  | CallIndirect of tableidx * typeidx   (* call function through table *)
+  | ReturnCall of funcidx                (* tail-call function *)
+  | ReturnCallRef of typeidx             (* tail call through reference *)
+  | ReturnCallIndirect of tableidx * typeidx   (* tail-call function through table *)
+  | Throw of tagidx                      (* throw exception *)
+  | ThrowRef                            (* rethrow exception *)
   | TryTable of blocktype * catch list * instr list  (* handle exceptions *)
-  | LocalGet of idx                   (* read local idxiable *)
-  | LocalSet of idx                   (* write local idxiable *)
-  | LocalTee of idx                   (* write local idxiable and keep value *)
-  | GlobalGet of idx                  (* read global idxiable *)
-  | GlobalSet of idx                  (* write global idxiable *)
-  | TableGet of idx                   (* read table element *)
-  | TableSet of idx                   (* write table element *)
-  | TableSize of idx                  (* size of table *)
-  | TableGrow of idx                  (* grow table *)
-  | TableFill of idx                  (* fill table with unique value *)
-  | TableCopy of idx * idx            (* copy table range *)
-  | TableInit of idx * idx            (* initialize table range from segment *)
-  | ElemDrop of idx                   (* drop passive element segment *)
-  | Load of idx * loadop              (* read memory at address *)
-  | Store of idx * storeop            (* write memory at address *)
-  | VecLoad of idx * vloadop          (* read memory at address *)
-  | VecStore of idx * vstoreop        (* write memory at address *)
-  | VecLoadLane of idx * vlaneop * int  (* read single lane at address *)
-  | VecStoreLane of idx * vlaneop * int (* write single lane to address *)
-  | MemorySize of idx                 (* size of memory *)
-  | MemoryGrow of idx                 (* grow memory *)
-  | MemoryFill of idx                 (* fill memory range with value *)
-  | MemoryCopy of idx * idx           (* copy memory ranges *)
-  | MemoryInit of idx * idx           (* initialize memory range from segment *)
-  | DataDrop of idx                   (* drop passive data segment *)
-  | Const of num                      (* constant *)
-  | Test of testop                    (* numeric test *)
-  | Compare of relop                  (* numeric comparison *)
-  | Unary of unop                     (* unary numeric operator *)
-  | Binary of binop                   (* binary numeric operator *)
-  | Convert of cvtop                  (* conversion *)
-  | RefNull of heaptype               (* null reference *)
-  | RefFunc of idx                    (* function reference *)
-  | RefIsNull                         (* type test *)
-  | RefAsNonNull                      (* type cast *)
-  | RefTest of reftype                (* type test *)
-  | RefCast of reftype                (* type cast *)
-  | RefEq                             (* reference equality *)
-  | RefI31                            (* scalar reference *)
-  | I31Get of sx                      (* read scalar *)
-  | StructNew of idx * initop         (* allocate structure *)
-  | StructGet of idx * idx * sx option  (* read structure field *)
-  | StructSet of idx * idx            (* write structure field *)
-  | ArrayNew of idx * initop          (* allocate array *)
-  | ArrayNewFixed of idx * int32      (* allocate fixed array *)
-  | ArrayNewElem of idx * idx         (* allocate array from element segment *)
-  | ArrayNewData of idx * idx         (* allocate array from data segment *)
-  | ArrayGet of idx * sx option       (* read array slot *)
-  | ArraySet of idx                   (* write array slot *)
-  | ArrayLen                          (* read array length *)
-  | ArrayCopy of idx * idx            (* copy between two arrays *)
-  | ArrayFill of idx                  (* fill array with value *)
-  | ArrayInitData of idx * idx        (* fill array from data segment *)
-  | ArrayInitElem of idx * idx        (* fill array from elem segment *)
-  | ExternConvert of externop         (* extern conversion *)
-  | VecConst of vec                   (* constant *)
-  | VecTest of vtestop                (* vector test *)
-  | VecCompare of vrelop              (* vector comparison *)
-  | VecUnary of vunop                 (* unary vector operator *)
-  | VecBinary of vbinop               (* binary vector operator *)
-  | VecTernary of vternop             (* ternary vector operator *)
-  | VecConvert of vcvtop              (* vector conversion *)
-  | VecShift of vshiftop              (* vector shifts *)
-  | VecBitmask of vbitmaskop          (* vector masking *)
-  | VecTestBits of vvtestop           (* vector bit test *)
-  | VecUnaryBits of vvunop            (* unary bit vector operator *)
-  | VecBinaryBits of vvbinop          (* binary bit vector operator *)
-  | VecTernaryBits of vvternop        (* ternary bit vector operator *)
-  | VecSplat of vsplatop              (* number to vector conversion *)
-  | VecExtract of vextractop          (* extract lane from vector *)
-  | VecReplace of vreplaceop          (* replace lane in vector *)
+  | LocalGet of localidx                 (* read local variable *)
+  | LocalSet of localidx                 (* write local variable *)
+  | LocalTee of localidx                 (* write local variable & keep value *)
+  | GlobalGet of globalidx               (* read global variable *)
+  | GlobalSet of globalidx               (* write global variable *)
+  | TableGet of tableidx                 (* read table element *)
+  | TableSet of tableidx                 (* write table element *)
+  | TableSize of tableidx                (* size of table *)
+  | TableGrow of tableidx                (* grow table *)
+  | TableFill of tableidx                (* fill table with unique value *)
+  | TableCopy of tableidx * tableidx     (* copy table range *)
+  | TableInit of tableidx * elemidx      (* initialize table range from elems *)
+  | ElemDrop of elemidx                  (* drop passive element segment *)
+  | Load of memoryidx * loadop           (* read memory at address *)
+  | Store of memoryidx * storeop         (* write memory at address *)
+  | VecLoad of memoryidx * vloadop       (* read memory at address *)
+  | VecStore of memoryidx * vstoreop     (* write memory at address *)
+  | VecLoadLane of memoryidx * vlaneop * laneidx  (* read single lane at address *)
+  | VecStoreLane of memoryidx * vlaneop * laneidx (* write single lane to address *)
+  | MemorySize of memoryidx              (* size of memory *)
+  | MemoryGrow of memoryidx              (* grow memory *)
+  | MemoryFill of memoryidx              (* fill memory range with value *)
+  | MemoryCopy of memoryidx * memoryidx  (* copy memory ranges *)
+  | MemoryInit of memoryidx * dataidx    (* initialize memory range from data *)
+  | DataDrop of dataidx                  (* drop passive data segment *)
+  | Const of num                         (* constant *)
+  | Test of testop                       (* numeric test *)
+  | Compare of relop                     (* numeric comparison *)
+  | Unary of unop                        (* unary numeric operator *)
+  | Binary of binop                      (* binary numeric operator *)
+  | Convert of cvtop                     (* conversion *)
+  | RefNull of heaptype                  (* null reference *)
+  | RefFunc of funcidx                   (* function reference *)
+  | RefIsNull                            (* type test *)
+  | RefAsNonNull                         (* type cast *)
+  | RefTest of reftype                   (* type test *)
+  | RefCast of reftype                   (* type cast *)
+  | RefEq                                (* reference equality *)
+  | RefI31                               (* scalar reference *)
+  | I31Get of sx                         (* read scalar *)
+  | StructNew of typeidx * initop        (* allocate structure *)
+  | StructGet of typeidx * fieldidx * sx option  (* read structure field *)
+  | StructSet of typeidx * fieldidx      (* write structure field *)
+  | ArrayNew of typeidx * initop         (* allocate array *)
+  | ArrayNewFixed of typeidx * int32     (* allocate fixed array *)
+  | ArrayNewData of typeidx * dataidx    (* allocate array from data *)
+  | ArrayNewElem of typeidx * elemidx    (* allocate array from elements *)
+  | ArrayGet of typeidx * sx option      (* read array slot *)
+  | ArraySet of typeidx                  (* write array slot *)
+  | ArrayLen                             (* read array length *)
+  | ArrayCopy of typeidx * typeidx       (* copy between two arrays *)
+  | ArrayFill of typeidx                 (* fill array with value *)
+  | ArrayInitData of typeidx * dataidx   (* fill array from data segment *)
+  | ArrayInitElem of typeidx * elemidx   (* fill array from elem segment *)
+  | ExternConvert of externop            (* extern conversion *)
+  | VecConst of vec                      (* constant *)
+  | VecTest of vtestop                   (* vector test *)
+  | VecCompare of vrelop                 (* vector comparison *)
+  | VecUnary of vunop                    (* unary vector operator *)
+  | VecBinary of vbinop                  (* binary vector operator *)
+  | VecTernary of vternop                (* ternary vector operator *)
+  | VecConvert of vcvtop                 (* vector conversion *)
+  | VecShift of vshiftop                 (* vector shifts *)
+  | VecBitmask of vbitmaskop             (* vector masking *)
+  | VecTestBits of vvtestop              (* vector bit test *)
+  | VecUnaryBits of vvunop               (* unary bit vector operator *)
+  | VecBinaryBits of vvbinop             (* binary bit vector operator *)
+  | VecTernaryBits of vvternop           (* ternary bit vector operator *)
+  | VecSplat of vsplatop                 (* number to vector conversion *)
+  | VecExtract of vextractop             (* extract lane from vector *)
+  | VecReplace of vreplaceop             (* replace lane in vector *)
 
 and catch = catch' Source.phrase
 and catch' =
-  | Catch of idx * idx
-  | CatchRef of idx * idx
-  | CatchAll of idx
-  | CatchAllRef of idx
+  | Catch of tagidx * labelidx
+  | CatchRef of tagidx * labelidx
+  | CatchAll of tagidx
+  | CatchAllRef of tagidx
 
 
 (* Modules *)
@@ -285,7 +299,7 @@ and local' =
 
 type func = func' Source.phrase
 and func' =
-  | Func of idx * local list * instr list
+  | Func of typeidx * local list * instr list
 
 type segmentmode = segmentmode' Source.phrase
 and segmentmode' =
@@ -303,15 +317,15 @@ and elem' =
 
 type start = start' Source.phrase
 and start' =
-  | Start of idx
+  | Start of funcidx
 
 type externidx = externidx' Source.phrase
 and externidx' =
-  | TagX of idx
-  | GlobalX of idx
-  | MemoryX of idx
-  | TableX of idx
-  | FuncX of idx
+  | TagX of tagidx
+  | GlobalX of globalidx
+  | MemoryX of memoryidx
+  | TableX of tableidx
+  | FuncX of funcidx
 
 type export = export' Source.phrase
 and export' =
diff --git a/interpreter/text/arrange.ml b/interpreter/text/arrange.ml
index 74efb7d00..e8e3a5d52 100644
--- a/interpreter/text/arrange.ml
+++ b/interpreter/text/arrange.ml
@@ -561,9 +561,9 @@ let rec instr e =
     | RefI31 -> "ref.i31", []
     | I31Get sx -> "i31.get" ^ ext sx, []
     | StructNew (x, op) -> "struct.new" ^ initop op ^ " " ^ idx x, []
-    | StructGet (x, y, sxo) ->
-      "struct.get" ^ opt_s ext sxo ^ " " ^ idx x ^ " " ^ idx y, []
-    | StructSet (x, y) -> "struct.set " ^ idx x ^ " " ^ idx y, []
+    | StructGet (x, i, sxo) ->
+      "struct.get" ^ opt_s ext sxo ^ " " ^ idx x ^ " " ^ nat32 i, []
+    | StructSet (x, i) -> "struct.set " ^ idx x ^ " " ^ nat32 i, []
     | ArrayNew (x, op) -> "array.new" ^ initop op ^ " " ^ idx x, []
     | ArrayNewFixed (x, n) -> "array.new_fixed " ^ idx x ^ " " ^ nat32 n, []
     | ArrayNewElem (x, y) -> "array.new_elem " ^ idx x ^ " " ^ idx y, []
@@ -844,9 +844,9 @@ let lane_pat mode pat shape =
   let choose fb ft = if mode = `Binary then fb else ft in
   match pat, shape with
   | NumPat {it = Value.I32 i; _}, V128.I8x16 () ->
-    choose I8.to_hex_string I8.to_string_s i
+    choose I8.to_hex_string I8.to_string_s (I8.of_i32_u i)
   | NumPat {it = Value.I32 i; _}, V128.I16x8 () ->
-    choose I16.to_hex_string I16.to_string_s i
+    choose I16.to_hex_string I16.to_string_s (I16.of_i32_u i)
   | NumPat n, _ -> num mode n.it
   | NanPat nan, _ -> nanop nan
 
diff --git a/interpreter/text/parser.mly b/interpreter/text/parser.mly
index 96b3fed20..14acfc6b5 100644
--- a/interpreter/text/parser.mly
+++ b/interpreter/text/parser.mly
@@ -52,8 +52,8 @@ let vec_lane_nan shape l at =
 let vec_lane_lit shape l at =
   let open Value in
   match shape with
-  | V128.I8x16 () -> NumPat (I32 (I8.of_string l) @@@ at)
-  | V128.I16x8 () -> NumPat (I32 (I16.of_string l) @@@ at)
+  | V128.I8x16 () -> NumPat (I32 (I8.to_i32_u (I8.of_string l)) @@@ at)
+  | V128.I16x8 () -> NumPat (I32 (I16.to_i32_u (I16.of_string l)) @@@ at)
   | V128.I32x4 () -> NumPat (I32 (I32.of_string l) @@@ at)
   | V128.I64x2 () -> NumPat (I64 (I64.of_string l) @@@ at)
   | V128.F32x4 () -> NumPat (F32 (F32.of_string l) @@@ at)
@@ -310,7 +310,7 @@ let parse_annots (m : module_) : Custom.section list =
 %token<Ast.instr'> I31_GET
 %token<Ast.idx -> Ast.instr'> STRUCT_NEW ARRAY_NEW ARRAY_GET
 %token STRUCT_SET
-%token<Ast.idx -> Ast.idx -> Ast.instr'> STRUCT_GET
+%token<Ast.idx -> int32 -> Ast.instr'> STRUCT_GET
 %token ARRAY_NEW_FIXED ARRAY_NEW_ELEM ARRAY_NEW_DATA
 %token ARRAY_SET ARRAY_LEN
 %token ARRAY_COPY ARRAY_FILL ARRAY_INIT_DATA ARRAY_INIT_ELEM
@@ -623,8 +623,8 @@ plain_instr :
   | REF_I31 { fun c -> ref_i31 }
   | I31_GET { fun c -> $1 }
   | STRUCT_NEW idx { fun c -> $1 ($2 c type_) }
-  | STRUCT_GET idx idx { fun c -> let x = $2 c type_ in $1 x ($3 c (field x.it)) }
-  | STRUCT_SET idx idx { fun c -> let x = $2 c type_ in struct_set x ($3 c (field x.it)) }
+  | STRUCT_GET idx idx { fun c -> let x = $2 c type_ in $1 x ($3 c (field x.it)).it }
+  | STRUCT_SET idx idx { fun c -> let x = $2 c type_ in struct_set x ($3 c (field x.it)).it }
   | ARRAY_NEW idx { fun c -> $1 ($2 c type_) }
   | ARRAY_NEW_FIXED idx nat32 { fun c -> array_new_fixed ($2 c type_) $3 }
   | ARRAY_NEW_ELEM idx idx { fun c -> array_new_elem ($2 c type_) ($3 c elem) }
diff --git a/interpreter/valid/valid.ml b/interpreter/valid/valid.ml
index 5e4162b0e..aa92bba09 100644
--- a/interpreter/valid/valid.ml
+++ b/interpreter/valid/valid.ml
@@ -764,22 +764,22 @@ let rec check_instr (c : context) (e : instr) (s : infer_resulttype) : infer_ins
     let ts = if initop = Implicit then [] else List.map unpacked_fieldtype fts in
     ts --> [RefT (NoNull, UseHT (Def (type_ c x)))], []
 
-  | StructGet (x, y, exto) ->
+  | StructGet (x, i, exto) ->
     let StructT fts = struct_type c x in
-    require (y.it < Lib.List32.length fts) y.at
-      ("unknown field " ^ I32.to_string_u y.it);
-    let FieldT (_mut, st) = Lib.List32.nth fts y.it in
-    require ((exto <> None) == is_packed_storagetype st) y.at
+    require (i < Lib.List32.length fts) e.at
+      ("unknown field " ^ I32.to_string_u i);
+    let FieldT (_mut, st) = Lib.List32.nth fts i in
+    require ((exto <> None) == is_packed_storagetype st) e.at
       ("field is " ^ (if exto = None then "packed" else "unpacked"));
     let t = unpacked_storagetype st in
     [RefT (Null, UseHT (Def (type_ c x)))] --> [t], []
 
-  | StructSet (x, y) ->
+  | StructSet (x, i) ->
     let StructT fts = struct_type c x in
-    require (y.it < Lib.List32.length fts) y.at
-      ("unknown field " ^ I32.to_string_u y.it);
-    let FieldT (mut, st) = Lib.List32.nth fts y.it in
-    require (mut == Var) y.at "field is immutable";
+    require (i < Lib.List32.length fts) e.at
+      ("unknown field " ^ I32.to_string_u i);
+    let FieldT (mut, st) = Lib.List32.nth fts i in
+    require (mut == Var) e.at "field is immutable";
     let t = unpacked_storagetype st in
     [RefT (Null, UseHT (Def (type_ c x))); t] --> [], []
 
